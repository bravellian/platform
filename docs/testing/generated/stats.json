{
  "generatedAtUtc": "2026-01-26T16:16:16.6666716Z",
  "repo": {
    "defaultBranch": "main"
  },
  "summary": {
    "total": 674,
    "compliant": 670,
    "missingRequired": 4,
    "invalidFormat": 0
  },
  "byCategory": [
    {
      "category": "Bravellian.Platform.HealthProbe",
      "total": 17,
      "compliant": 17
    },
    {
      "category": "Bravellian.Platform.Tests",
      "total": 644,
      "compliant": 641
    },
    {
      "category": "Modularity",
      "total": 13,
      "compliant": 12
    }
  ],
  "byTag": [],
  "byProject": [
    {
      "project": "Bravellian.Platform.HealthProbe.Tests",
      "total": 17,
      "compliant": 17
    },
    {
      "project": "Bravellian.Platform.Postgres.Tests",
      "total": 218,
      "compliant": 218
    },
    {
      "project": "Bravellian.Platform.Tests",
      "total": 439,
      "compliant": 435
    }
  ],
  "tests": [
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseDefaultsToConfiguredEndpoint",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "Given only the base command, then parsing leaves EndpointName null and JsonOutput false.",
      "intent": "Describe default parsing with no endpoint or flags.",
      "scenario": "Given arguments containing only \u0022healthcheck\u0022.",
      "behavior": "EndpointName remains null and JsonOutput stays false.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 33,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseDefaultsToConfiguredEndpoint"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseThrowsForUnknownFlag",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When an unknown flag is provided, then parsing throws a HealthProbeArgumentException.",
      "intent": "Describe parsing failure for unsupported command line options.",
      "scenario": "Given arguments including an unrecognized \u0022--nope\u0022 option.",
      "behavior": "Parsing throws and the message mentions an unknown option.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 96,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseThrowsForUnknownFlag"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesExplicitEndpointName",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "Given an explicit endpoint argument, then parsing uses it as EndpointName.",
      "intent": "Describe parsing of a positional endpoint argument.",
      "scenario": "Given arguments \u0022healthcheck\u0022 and \u0022deploy\u0022.",
      "behavior": "EndpointName is \u0022deploy\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesExplicitEndpointName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesOverrides",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When override flags are provided, then parsing populates each override option.",
      "intent": "Describe parsing of URL, timeout, header, API key, TLS, and JSON flags.",
      "scenario": "Given arguments with url, timeout, header, apikey, insecure, and json options.",
      "behavior": "EndpointName and all override properties match the provided values.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 58,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.ParseUsesOverrides"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.TryRunReturnsInvalidWhenUrlMissing",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "Given no URL override, then running the health check returns InvalidArguments.",
      "intent": "Describe validation when required URL input is missing.",
      "scenario": "Given a service provider and a command line containing only \u0022healthcheck\u0022.",
      "behavior": "The returned exit code is InvalidArguments.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeCommandLineTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeCommandLineTests.TryRunReturnsInvalidWhenUrlMissing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsLivePathWhenBaseHasNoPath",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When resolving the live endpoint against a base URL with no path, then /live is appended.",
      "intent": "Describe URL resolution for an explicit endpoint name.",
      "scenario": "Given a base URL without a path and a live endpoint mapping.",
      "behavior": "The resolved URL is https://example.test/live.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 33,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsLivePathWhenBaseHasNoPath"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsReadyPathWhenBaseHasNoPath",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "Given a base URL with no path and a default ready endpoint, then resolution appends /ready.",
      "intent": "Describe URL resolution for the default endpoint.",
      "scenario": "Given a base URL without a path, a ready endpoint path, and no override URL.",
      "behavior": "The resolved URL is https://example.test/ready and EndpointName is ready.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 13,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveAppendsReadyPathWhenBaseHasNoPath"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveNormalizesPathWhenReadyPathIsRelative",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When the endpoint path is relative, then resolution combines it with the base URL.",
      "intent": "Describe resolution behavior for relative endpoint paths.",
      "scenario": "Given a base URL and a ready endpoint path without a leading slash.",
      "behavior": "The resolved URL is https://example.test/readyz.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 69,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveNormalizesPathWhenReadyPathIsRelative"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesExplicitPathWhenProvided",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "Given an endpoint mapped to an absolute URL, then resolution uses that URL.",
      "intent": "Describe resolution behavior for absolute endpoint URLs.",
      "scenario": "Given an endpoint configured with https://example.test/healthz.",
      "behavior": "The resolved URL matches the configured absolute URL.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 51,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesExplicitPathWhenProvided"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesOverrideUrlWhenProvided",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When an override URL is provided, then resolution returns the override and preserves the endpoint name.",
      "intent": "Describe precedence of override URLs.",
      "scenario": "Given a configured endpoint and an explicit override URL.",
      "behavior": "The resolved URL matches the override and EndpointName remains \u0022deploy\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HealthProbeUrlResolverTests.cs",
        "line": 88,
        "member": "Bravellian.Platform.HealthProbe.Tests.HealthProbeUrlResolverTests.ResolveUsesOverrideUrlWhenProvided"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncAddsApiKeyHeaderWhenConfigured",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When API key settings are configured, then the probe request includes the API key header.",
      "intent": "Describe how API key options affect probe request headers.",
      "scenario": "Given options with ApiKey and ApiKeyHeaderName set in the runner.",
      "behavior": "The outgoing request contains the configured header and value.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 151,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncAddsApiKeyHeaderWhenConfigured"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncDoesNotTreatNonSuccessStatusAsHealthyEvenWhenJsonIsHealthy",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When the HTTP status is non-success, then the result is unhealthy even if JSON says Healthy.",
      "intent": "Describe precedence of HTTP status over JSON health status.",
      "scenario": "Given a ServiceUnavailable response whose JSON body reports \u0022Healthy\u0022.",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 101,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncDoesNotTreatNonSuccessStatusAsHealthyEvenWhenJsonIsHealthy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsExceptionExitCodeOnTimeout",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe times out, then the result uses the exception exit code.",
      "intent": "Describe timeout handling for HTTP probes.",
      "scenario": "Given a runner with a short timeout and a handler that delays beyond it.",
      "behavior": "The result is unhealthy and the exit code is Exception.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 125,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsExceptionExitCodeOnTimeout"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyForSuccessStatus",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe handler returns 200 OK, then the result is healthy.",
      "intent": "Describe how a success HTTP status maps to a healthy probe result.",
      "scenario": "Given a runner using a stub handler that returns HttpStatusCode.OK.",
      "behavior": "The result is healthy and the exit code is Healthy.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 17,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyForSuccessStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyWhenJsonStatusIsHealthy",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When a 200 OK response body reports Healthy, then the result is healthy.",
      "intent": "Describe how a JSON health status maps to the probe outcome.",
      "scenario": "Given a stubbed 200 OK response with JSON status \u0022Healthy\u0022.",
      "behavior": "The result is healthy and the exit code is Healthy.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsHealthyWhenJsonStatusIsHealthy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyForFailureStatus",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When the probe handler returns a failure status, then the result is unhealthy.",
      "intent": "Describe how non-success HTTP status maps to an unhealthy probe result.",
      "scenario": "Given a runner using a stub handler that returns ServiceUnavailable.",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 35,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyForFailureStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.HealthProbe.Tests:Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyWhenJsonStatusIsUnhealthy",
      "category": "Bravellian.Platform.HealthProbe",
      "tags": [],
      "summary": "When a 200 OK response body reports Unhealthy, then the result is unhealthy.",
      "intent": "Describe how a JSON health status maps to the probe outcome.",
      "scenario": "Given a stubbed 200 OK response with JSON status \u0022Unhealthy\u0022.",
      "behavior": "The result is unhealthy and the exit code is Unhealthy.",
      "source": {
        "file": "tests/Bravellian.Platform.HealthProbe.Tests/HttpHealthProbeRunnerTests.cs",
        "line": 53,
        "member": "Bravellian.Platform.HealthProbe.Tests.HttpHealthProbeRunnerTests.RunAsyncReturnsUnhealthyWhenJsonStatusIsUnhealthy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.HealthProbe.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the distributed lock schema is ensured with a custom schema, then the table is created there.",
      "intent": "Verify distributed lock deployment honors the configured schema name.",
      "scenario": "Given EnsureDistributedLockSchemaAsync is called with the \u0022platform\u0022 schema and table name \u0022DistributedLock\u0022.",
      "behavior": "The DistributedLock table is present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 49,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the fanout schema is ensured with a custom schema, then policy and cursor tables are created there.",
      "intent": "Verify fanout deployment honors the configured schema name.",
      "scenario": "Given EnsureFanoutSchemaAsync is called with the \u0022platform\u0022 schema and custom table names.",
      "behavior": "FanoutPolicy and FanoutCursor tables are present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 260,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox schema is ensured with a custom schema, then the Inbox table is created there.",
      "intent": "Verify inbox deployment honors the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync is called with the \u0022platform\u0022 schema and table name \u0022Inbox\u0022.",
      "behavior": "The Inbox table is present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 133,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox work-queue schema is ensured with a custom schema, then inbox objects are created there.",
      "intent": "Verify inbox work-queue deployment honors the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync and EnsureInboxWorkQueueSchemaAsync are called with the \u0022platform\u0022 schema.",
      "behavior": "The Inbox table is present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 229,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the lease schema is ensured with a custom schema, then the lease table is created there.",
      "intent": "Verify lease deployment honors the configured schema name.",
      "scenario": "Given EnsureLeaseSchemaAsync is called with the \u0022platform\u0022 schema and table name \u0022Lease\u0022.",
      "behavior": "The Lease table is present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 76,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the outbox schema is ensured with a custom schema, then outbox tables are created there.",
      "intent": "Verify outbox deployment honors the configured schema name.",
      "scenario": "Given EnsureOutboxSchemaAsync is called with the \u0022platform\u0022 schema and table name \u0022Outbox\u0022.",
      "behavior": "The Outbox and OutboxState tables are present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 103,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the scheduler schema is ensured with a custom schema, then scheduler tables are created there.",
      "intent": "Verify scheduler deployment honors the configured schema name.",
      "scenario": "Given EnsureSchedulerSchemaAsync is called with the \u0022platform\u0022 schema and custom table names.",
      "behavior": "Jobs, Timers, JobRuns, and SchedulerState tables are present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the work-queue schema is ensured with a custom schema, then work-queue objects use that schema.",
      "intent": "Verify work-queue deployment honors the configured schema name.",
      "scenario": "Given EnsureOutboxSchemaAsync and EnsureWorkQueueSchemaAsync are called with the \u0022platform\u0022 schema.",
      "behavior": "The Outbox table is present in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/CustomSchemaIntegrationTests.cs",
        "line": 198,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When creating scheduler tables in a custom schema, then tables and indexes use the custom names.",
      "intent": "Verify scheduler schema respects custom schema and table names.",
      "scenario": "Given EnsureSchedulerSchemaAsync is called with schema custom_test and custom table names.",
      "behavior": "CustomJobs, CustomJobRuns, and CustomTimers tables exist with the expected index name.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 279,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given core schemas are deployed, then all required tables exist.",
      "intent": "Verify core schema deployment creates the expected tables.",
      "scenario": "Given Outbox, Inbox, Scheduler, and Fanout schemas ensured in the infra schema.",
      "behavior": "Each expected core table is present in infra.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 49,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_RequiredIndexesExist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When verifying schema indexes, then required work-queue and uniqueness indexes exist.",
      "intent": "Validate required indexes are created for core tables.",
      "scenario": "Given the infra schema with Outbox, Inbox, Jobs, Timers, and JobRuns tables.",
      "behavior": "All expected indexes are present in PostgreSQL metadata.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 244,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_RequiredIndexesExist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Inbox table, then all required columns and types match.",
      "intent": "Validate the Inbox table shape matches the expected schema.",
      "scenario": "Given the infra.Inbox table created by schema deployment.",
      "behavior": "Each required Inbox column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 210,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the JobRuns table, then all required columns and types match.",
      "intent": "Validate the JobRuns table shape matches the expected schema.",
      "scenario": "Given the infra.JobRuns table created by schema deployment.",
      "behavior": "Each required JobRuns column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 176,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Jobs table, then all required columns and types match.",
      "intent": "Validate the Jobs table shape matches the expected schema.",
      "scenario": "Given the infra.Jobs table created by schema deployment.",
      "behavior": "Each required Jobs column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 112,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Outbox table, then all required columns and types match.",
      "intent": "Validate the Outbox table shape matches the expected schema.",
      "scenario": "Given the infra.Outbox table created by schema deployment.",
      "behavior": "Each required Outbox column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Timers table, then all required columns and types match.",
      "intent": "Validate the Timers table shape matches the expected schema.",
      "scenario": "Given the infra.Timers table created by schema deployment.",
      "behavior": "Each required Timers column exists with the expected PostgreSQL data type.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 141,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When checking the Outbox table after work-queue migration, then work-queue columns exist.",
      "intent": "Confirm work-queue columns are present after migration.",
      "scenario": "Given the infra.Outbox table created by schema deployment.",
      "behavior": "Status, LockedUntil, and OwnerToken columns are present.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 311,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithControlPlane_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When control-plane schema deployment is enabled, then schema services are registered.",
      "intent": "Confirm control-plane multi-database registration wires schema deployment services.",
      "scenario": "Given a ServiceCollection, tenant list, and control-plane options with EnableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 154,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithControlPlane_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based schema deployment is disabled, then schema services are not registered.",
      "intent": "Confirm list-based multi-database registration skips schema deployment services.",
      "scenario": "Given a ServiceCollection, one PlatformDatabase entry, and enableSchemaDeployment set to false.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 190,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based multi-database schema deployment is enabled, then schema services are registered.",
      "intent": "Confirm list-based multi-database registration wires schema deployment services.",
      "scenario": "Given a ServiceCollection, one PlatformDatabase entry, and enableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 125,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is disabled, then Postgres outbox does not register schema services.",
      "intent": "Validate service registration is skipped when schema deployment is off.",
      "scenario": "Given a ServiceCollection and PostgresOutboxOptions with EnableSchemaDeployment set to false.",
      "behavior": "The service collection lacks IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService registrations.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then Postgres outbox registers schema completion and background services.",
      "intent": "Validate service registration for the outbox schema deployment path.",
      "scenario": "Given a ServiceCollection and PostgresOutboxOptions with EnableSchemaDeployment set to true.",
      "behavior": "The service collection contains IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService registrations.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 29,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPostgresOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SetCompleted is called, then SchemaDeploymentCompleted finishes successfully.",
      "intent": "Verify schema completion signaling transitions the task to a completed state.",
      "scenario": "Given a new DatabaseSchemaCompletion instance with an incomplete task.",
      "behavior": "The completion task becomes completed with status RanToCompletion.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 108,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then schema completion is registered separately from the background service.",
      "intent": "Ensure completion services are singletons independent of the hosted service registration.",
      "scenario": "Given AddPostgresOutbox is called with EnableSchemaDeployment set to true.",
      "behavior": "IDatabaseSchemaCompletion and DatabaseSchemaCompletion are singletons and the background service is registered.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 75,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When fanout slices are joined, then completed steps are idempotent and correlation ids remain consistent.",
      "intent": "Verify join-store idempotency for downstream fan-in tracking.",
      "scenario": "Given three fanout slices sharing one correlation id and a join expecting three steps.",
      "behavior": "CompletedSteps stays at three after replay and all outbox messages share the same correlation id.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 201,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When slices are abandoned, then subsequent runs redispatch them.",
      "intent": "Verify abandoned slices are eligible for redispatch.",
      "scenario": "Given a static planner with one analytics slice and an in-memory lease factory.",
      "behavior": "Two runs dispatch two messages and payloads include tenant-7.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 130,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then the coordinator skips dispatch until the lease expires.",
      "intent": "Verify lease gating and recovery behavior for fanout coordination.",
      "scenario": "Given a pre-acquired lease for fanout:billing and a planner with one slice.",
      "behavior": "The first run dispatches 0, a later run dispatches 1, and one outbox row is created.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 93,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cursors are marked completed, then subsequent runs skip those slices.",
      "intent": "Verify cursor advancement prevents redispatch of completed slices.",
      "scenario": "Given a sharded planner with two shards and cursors marked completed for both.",
      "behavior": "The initial run dispatches two slices and the follow-up run dispatches zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 164,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox table is missing, then the cleanup service runs without recreating it.",
      "intent": "Verify cleanup handles missing tables without side effects.",
      "scenario": "Given the inbox table is dropped and the cleanup service runs with a short interval.",
      "behavior": "The service completes and the inbox table still does not exist.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 249,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a seven-day retention period, then only old processed messages are deleted.",
      "intent": "Verify cleanup deletes processed rows older than the retention window.",
      "scenario": "Given one processed message older than 7 days, one recent processed message, and one unprocessed message.",
      "behavior": "Cleanup deletes only the old processed row and leaves the recent and unprocessed rows intact.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 55,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup uses a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Verify cleanup uses the retention cutoff to select deletions.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Two oldest rows are deleted and the three newest rows remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 185,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given only recent processed messages, then cleanup deletes nothing.",
      "intent": "Verify cleanup leaves processed rows inside the retention window.",
      "scenario": "Given a single processed message with ProcessedUtc within the retention window.",
      "behavior": "Deleted count is 0 and the row remains.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxCleanupTests.cs",
        "line": 137,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync executes across multiple runs, then owner tokens rotate between runs.",
      "intent": "Verify each dispatch run uses a new owner token.",
      "scenario": "Given a stub store with two messages and two sequential dispatcher runs.",
      "behavior": "Two distinct owner tokens are recorded across the runs.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 287,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails and a backoff policy is configured, then the message is abandoned with that delay.",
      "intent": "Verify backoff delays are applied during abandon.",
      "scenario": "Given a stub work store, a failing handler, and a backoff policy returning five seconds.",
      "behavior": "The message is abandoned once with the configured delay and no failures are recorded.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 207,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then RunOnceAsync abandons the message back to Seen.",
      "intent": "Verify handler failures result in a retryable abandon.",
      "scenario": "Given an enqueued failing-topic message and a handler that throws.",
      "behavior": "The processed count is 1 and the message status returns to Seen.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 165,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then RunOnceAsync marks the message Dead.",
      "intent": "Verify missing handlers move the message to Dead.",
      "scenario": "Given an enqueued unknown-topic message and a resolver with no handlers.",
      "behavior": "The processed count is 1 and the database status is Dead for msg-2.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 124,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given no inbox messages, then RunOnceAsync returns 0 processed items.",
      "intent": "Verify the dispatcher reports zero when no work is available.",
      "scenario": "Given an inbox work store and resolver with no enqueued messages.",
      "behavior": "The processed count is 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 56,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message exceeds max attempts, then RunOnceAsync fails it instead of retrying.",
      "intent": "Verify poison messages are failed once they exceed the retry limit.",
      "scenario": "Given a failing handler, a stub message at attempt 5, and maxAttempts set to 5.",
      "behavior": "The message is recorded as failed and no abandon entries are created.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 247,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a queued message has a matching handler, then RunOnceAsync processes it and marks it Done.",
      "intent": "Verify successful dispatch updates the inbox status to Done.",
      "scenario": "Given an enqueued test-topic message and a resolver with a matching handler.",
      "behavior": "The processed count is 1 and the database status is Done for msg-1.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxDispatcherTests.cs",
        "line": 83,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given a direct inbox workflow, then AlreadyProcessed transitions from false to true and the row is Done.",
      "intent": "Verify end-to-end inbox processing with direct PostgresInboxService usage.",
      "scenario": "Given a PostgresInboxService configured with infra.Inbox and a test message id.",
      "behavior": "The first AlreadyProcessedAsync is false, after MarkProcessing/MarkProcessed it is true, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 48,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple threads call AlreadyProcessedAsync concurrently, then one row is created with attempts tracked.",
      "intent": "Verify concurrent deduplication records a single row and increments Attempts.",
      "scenario": "Given ten concurrent tasks invoking AlreadyProcessedAsync for the same message id.",
      "behavior": "All calls return false, only one row exists, and Attempts equals the task count.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 138,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is marked dead after processing starts, then its status is Dead and ProcessedUtc stays null.",
      "intent": "Verify poison-message handling in the inbox workflow.",
      "scenario": "Given a PostgresInboxService and a message marked Processing then Dead.",
      "behavior": "The database row shows Status Dead and no ProcessedUtc value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxIntegrationTests.cs",
        "line": 96,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When abandoning a claimed message, then its status returns to Seen.",
      "intent": "Verify abandon releases the claim and resets the status.",
      "scenario": "Given a message claimed by an owner token.",
      "behavior": "Status is Seen and OwnerToken is cleared.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 182,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acknowledging a claimed message, then its status becomes Done.",
      "intent": "Verify acknowledgements finalize the inbox row.",
      "scenario": "Given a message claimed by an owner token.",
      "behavior": "Status is Done, OwnerToken is cleared, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 145,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is available, then ClaimAsync claims it and marks it Processing.",
      "intent": "Verify claims update inbox status and ownership.",
      "scenario": "Given one enqueued message and a new owner token.",
      "behavior": "The message id is returned and the row shows Status Processing with the owner token.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then only one receives the message.",
      "intent": "Verify claim exclusivity under concurrent workers.",
      "scenario": "Given one enqueued message and two owner tokens claiming at the same time.",
      "behavior": "Exactly one claim result contains the message id.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 114,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given an empty inbox, then ClaimAsync returns no message ids.",
      "intent": "Verify claim behavior when no work is available.",
      "scenario": "Given an inbox work store with no enqueued messages.",
      "behavior": "The claimed id list is empty.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 54,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When failing a claimed message, then its status becomes Dead.",
      "intent": "Verify failure handling marks the message as Dead.",
      "scenario": "Given a message claimed by an owner token and a failure reason.",
      "behavior": "Status is Dead and OwnerToken is cleared.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 218,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When requesting a missing message id, then GetAsync throws InvalidOperationException.",
      "intent": "Verify missing messages raise an exception.",
      "scenario": "Given an inbox store with no message matching \u0022non-existent\u0022.",
      "behavior": "An InvalidOperationException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 321,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given a valid message id, then GetAsync returns the stored inbox message.",
      "intent": "Verify message retrieval by id returns stored fields.",
      "scenario": "Given one enqueued message with id \u0022msg-1\u0022.",
      "behavior": "The returned message matches the stored fields and has Attempt 1.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 291,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to acknowledge a claim, then the row remains Processing.",
      "intent": "Verify owner token enforcement for state transitions.",
      "scenario": "Given a message claimed by one owner and an ack attempt by a different owner.",
      "behavior": "Status stays Processing and the OwnerToken remains the original owner.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/InboxWorkStoreTests.cs",
        "line": 254,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all join steps are completed, then the join remains in a completed state.",
      "intent": "Confirm the wait handler leaves a completed join unchanged.",
      "scenario": "Given a join expecting two steps with both steps marked completed.",
      "behavior": "CompletedSteps equals ExpectedSteps after handling the wait message.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 123,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAnyStepFailed_MarksJoinFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When any join step fails and failure propagation is enabled, then the join is marked failed.",
      "intent": "Validate failure propagation for join steps.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed enabled.",
      "behavior": "The join status is updated to Failed.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 168,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAnyStepFailed_MarksJoinFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the join has incomplete steps, then the handler throws JoinNotReadyException.",
      "intent": "Validate that the wait handler blocks until the join is complete.",
      "scenario": "Given a join expecting three steps with only one completed and FailIfAnyStepFailed enabled.",
      "behavior": "HandleAsync raises JoinNotReadyException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/JoinWaitHandlerTests.cs",
        "line": 87,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease has expired, then a new owner can acquire it and receives a new expiry.",
      "intent": "Verify acquisition succeeds after lease expiration.",
      "scenario": "Given a short-lived lease is acquired, allowed to expire, and then re-acquired by a new owner.",
      "behavior": "The second acquisition succeeds with serverUtcNow set and a non-null leaseUntilUtc.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 120,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring a free lease, then the acquisition succeeds and returns server time and expiry.",
      "intent": "Verify acquisition succeeds for an unused lease name.",
      "scenario": "Given a new lease name, an owner, and a 30-second lease duration.",
      "behavior": "The lease is acquired, serverUtcNow is set, and leaseUntilUtc is shortly after server time.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring an already-held lease, then the acquisition fails and returns server time.",
      "intent": "Verify acquisition fails for an occupied lease.",
      "scenario": "Given owner1 already holds the lease and owner2 attempts to acquire it.",
      "behavior": "The second acquisition fails, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing after the lease expires, then the renewal fails and returns no expiry.",
      "intent": "Verify renewal fails for an expired lease.",
      "scenario": "Given a short lease is acquired, allowed to expire, and then renewed by the same owner.",
      "behavior": "Renewed is false, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 230,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing with the current owner, then the lease is extended.",
      "intent": "Verify renewal succeeds for the lease holder.",
      "scenario": "Given a lease acquired by an owner and a subsequent renew attempt by the same owner.",
      "behavior": "Renewal succeeds, server time advances, and the lease expiry moves forward.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 158,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing with a different owner, then the renewal fails and no expiry is returned.",
      "intent": "Verify renewal fails for a non-owner.",
      "scenario": "Given owner1 holds the lease and owner2 attempts renewal.",
      "behavior": "Renewed is false, serverUtcNow is set, and leaseUntilUtc is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseTests.cs",
        "line": 196,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricDef table exists.",
      "intent": "Verify MetricDef is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricDef table in the infra schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricPointMinute table exists.",
      "intent": "Verify MetricPointMinute is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricPointMinute table in the infra schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 100,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given the metrics schema is deployed, then the MetricSeries table exists.",
      "intent": "Verify MetricSeries is created by the metrics schema deployment.",
      "scenario": "Given a database initialized with EnsureMetricsSchemaAsync.",
      "behavior": "INFORMATION_SCHEMA reports one MetricSeries table in the infra schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MetricsSchemaTests.cs",
        "line": 76,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given list-based registration, then control-plane configuration and tenant discovery are wired correctly.",
      "intent": "Verify list-based registration wires control-plane settings and discovery outputs.",
      "scenario": "Given two tenant databases, a control-plane database, and a service provider built with list registration.",
      "behavior": "Control-plane settings are populated and discovery/store providers return both tenant databases.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 56,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for multiple discovery-registered tenants, then each tenant message is processed.",
      "intent": "Verify multi-tenant outbox dispatch with discovery-based registration.",
      "scenario": "Given two tenant databases, discovery-based registration, and a capturing outbox handler.",
      "behavior": "Each outbox table records one processed row after dispatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 174,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for a single discovery-registered tenant, then its message is processed.",
      "intent": "Verify single-tenant outbox dispatch with discovery-based registration.",
      "scenario": "Given one tenant database, discovery-based registration, and a capturing outbox handler.",
      "behavior": "The tenant outbox table records one processed message.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 212,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for multiple list-registered tenants, then each tenant message is processed.",
      "intent": "Verify multi-tenant outbox dispatch with list-based registration.",
      "scenario": "Given two tenant databases, list-based registration, and a capturing outbox handler.",
      "behavior": "Each tenant payload is handled and each outbox table records one processed row.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 100,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dispatching for a single list-registered tenant, then its message is processed.",
      "intent": "Verify single-tenant outbox dispatch with list-based registration.",
      "scenario": "Given one tenant database, list-based registration, and a capturing outbox handler.",
      "behavior": "The tenant outbox table records one processed message.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 139,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes the inbox batch.",
      "intent": "Verify lease-based coordination prevents concurrent processing.",
      "scenario": "Given five inbox messages, a Postgres lease factory, and two dispatchers running concurrently.",
      "behavior": "One dispatcher processes all five messages while the other processes none, totaling five handled messages.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no lease router is configured, then the dispatcher processes all available messages.",
      "intent": "Verify processing continues without lease coordination.",
      "scenario": "Given three inbox messages and a dispatcher created without a lease router.",
      "behavior": "The dispatcher processes all three messages and the handler records three payloads.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 176,
        "member": "Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes the outbox batch.",
      "intent": "Verify lease-based coordination prevents concurrent processing.",
      "scenario": "Given five outbox messages, a Postgres lease factory, and two dispatchers running concurrently.",
      "behavior": "One dispatcher processes all five messages while the other processes none.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 44,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no lease router is configured, then the dispatcher processes all available messages.",
      "intent": "Verify dispatch proceeds without lease coordination.",
      "scenario": "Given three outbox messages and a dispatcher created without a lease router.",
      "behavior": "The dispatcher processes all three messages and the handler records three payloads.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dispatching across multiple stores, then messages are processed from each store.",
      "intent": "Verify the dispatcher iterates across store providers and handles messages from each.",
      "scenario": "Given two schemas with one ready outbox message each and a shared handler.",
      "behavior": "Two runs process both messages and both outbox rows are marked processed.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiOutboxDispatcherTests.cs",
        "line": 42,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When using the drain-first strategy, then one store is drained before moving on.",
      "intent": "Verify the drain-first selection strategy exhausts one store before switching.",
      "scenario": "Given one store with three ready messages and a drain-first strategy.",
      "behavior": "Three runs process messages and the fourth run finds no work.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/MultiOutboxDispatcherTests.cs",
        "line": 159,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the outbox table is missing, then the cleanup service runs without recreating it.",
      "intent": "Verify cleanup handles missing tables without side effects.",
      "scenario": "Given the outbox table is dropped and the cleanup service runs with a short interval.",
      "behavior": "The service completes and the outbox table still does not exist.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 228,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a seven-day retention period, then only old processed messages are deleted.",
      "intent": "Verify cleanup removes processed rows older than the retention window.",
      "scenario": "Given one processed message older than 7 days, one recent processed message, and one unprocessed message.",
      "behavior": "Cleanup deletes only the old processed row and leaves the recent and unprocessed rows intact.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 48,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup uses a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Verify retention cutoffs are respected during cleanup.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Two oldest rows are deleted and the three newest rows remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 170,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When only recent processed messages exist, then cleanup deletes nothing.",
      "intent": "Verify cleanup does not remove rows inside the retention window.",
      "scenario": "Given a processed message with ProcessedAt within the retention period.",
      "behavior": "Deleted count is 0 and the row remains.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxCleanupTests.cs",
        "line": 128,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with full parameters, then the join.wait message contains them.",
      "intent": "Verify join-wait payload fields are populated from all provided parameters.",
      "scenario": "Given a join id with on-complete and on-fail topics/payloads.",
      "behavior": "The stored payload matches the join id, flags, and on-complete/on-fail values.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxExtensionsTests.cs",
        "line": 68,
        "member": "Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with minimal parameters, then optional fields remain null.",
      "intent": "Verify defaults are applied when optional join-wait parameters are omitted.",
      "scenario": "Given only a join id passed to EnqueueJoinWaitAsync.",
      "behavior": "The payload has the join id, FailIfAnyStepFailed true, and null optional fields.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxExtensionsTests.cs",
        "line": 108,
        "member": "Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When computing default backoff delays, then ranges grow exponentially with jitter and remain bounded.",
      "intent": "Verify the default backoff timing policy and caps.",
      "scenario": "Given backoff calculations for attempts 1, 2, 3, and 10.",
      "behavior": "Early attempts fall within expected jitter ranges and the maximum stays under two minutes.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 478,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws and attempts remain, then RunOnceAsync reschedules with backoff.",
      "intent": "Verify handler exceptions reschedule messages with delay.",
      "scenario": "Given a handler configured to throw and a message with RetryCount 2.",
      "behavior": "The message is rescheduled with a positive delay and the error is captured.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 217,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When processing a mix of success and missing-handler messages, then logs include info, debug, and warning entries.",
      "intent": "Verify log levels reflect batch, message, and missing-handler outcomes.",
      "scenario": "Given a capturing logger, one handled Test.Topic message, and one Unknown.Topic message.",
      "behavior": "The batch is processed and logs include Information for batch work, Debug for message processing, and Warning for missing handlers.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 401,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is processed successfully, then the handler and store record dispatch.",
      "intent": "Verify the success path invokes handlers and records dispatch.",
      "scenario": "Given a dispatcher with a matching handler and a test store containing one message.",
      "behavior": "Processed count is 1, the handler is invoked, and the store records dispatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 311,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails, then the dispatcher captures the error and reschedules the message.",
      "intent": "Verify handler failures produce reschedule entries with errors.",
      "scenario": "Given a handler configured to throw and a test store with one message.",
      "behavior": "The handler is invoked and the store records a reschedule with the exception message.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 356,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message has no registered handler, then RunOnceAsync marks it failed.",
      "intent": "Verify missing handlers cause failures with the correct error.",
      "scenario": "Given an empty resolver and a test store with one Unknown.Topic message.",
      "behavior": "Processed count is 1 and the store records a failure with a missing-handler error.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 176,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message has a matching handler, then RunOnceAsync dispatches it and returns 1.",
      "intent": "Verify successful single-message dispatch through the handler.",
      "scenario": "Given a test store with one Test.Topic message and a resolver with a matching handler.",
      "behavior": "Processed count is 1, the handler receives the message, and the store records dispatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 133,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a failing message reaches the max attempts threshold, then it is marked failed.",
      "intent": "Verify poison messages fail once the retry limit is reached.",
      "scenario": "Given a dispatcher with maxAttempts 3 and a message at RetryCount 2 that throws.",
      "behavior": "The message is recorded as failed and no reschedule occurs.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 264,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When resolving with different casing, then the handler is still found.",
      "intent": "Verify case-insensitive topic lookup in the resolver.",
      "scenario": "Given a resolver with a single handler for Email.Send.",
      "behavior": "TryGet succeeds for email.send and EMAIL.SEND while preserving the handler topic.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 106,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given a resolver with multiple handlers, then known topics resolve and unknown topics do not.",
      "intent": "Verify resolver matching for known and unknown topics.",
      "scenario": "Given handlers for Email.Send, SMS.Send, and Push.Notification.",
      "behavior": "TryGet returns true for Email.Send and SMS.Send, and false for NonExistent.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 71,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When adding an outbox handler factory, then it is registered as a singleton IOutboxHandler.",
      "intent": "Verify handler factory registration uses singleton lifetime.",
      "scenario": "Given a ServiceCollection configured with time abstractions and a factory delegate.",
      "behavior": "The registration stores an implementation factory with singleton lifetime.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 545,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When adding an outbox handler type, then it is registered as a singleton IOutboxHandler.",
      "intent": "Verify handler type registration uses singleton lifetime.",
      "scenario": "Given a ServiceCollection configured with time abstractions.",
      "behavior": "The registration uses TestHandler as the implementation type with singleton lifetime.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxHandlerTests.cs",
        "line": 516,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When attaching the same message twice, then only one association exists.",
      "intent": "Verify AttachMessageToJoinAsync is idempotent.",
      "scenario": "Given a join and a single outbox message attached twice.",
      "behavior": "The join member table contains a single row for that pair.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 187,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When attaching a message to a join, then the association is stored.",
      "intent": "Verify join member rows are created for attached messages.",
      "scenario": "Given an existing join and a created outbox message id.",
      "behavior": "The join member table has one row for the join/message pair.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 154,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all steps complete, then the join reports completed status and counts.",
      "intent": "Verify the full join workflow records completion for every step.",
      "scenario": "Given a join expecting three steps with three attached messages all completed.",
      "behavior": "CompletedSteps is 3, FailedSteps is 0, and Status is Completed.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 340,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When some steps fail, then the join reports failed status and counts.",
      "intent": "Verify the join workflow records failures alongside completions.",
      "scenario": "Given a join expecting three steps with two completed and one failed.",
      "behavior": "Status is Failed with CompletedSteps 2 and FailedSteps 1.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 384,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When CreateJoinAsync is called with valid parameters, then a pending join is created.",
      "intent": "Verify join creation populates expected metadata and counters.",
      "scenario": "Given a tenant id, expected steps, and metadata payload.",
      "behavior": "The join has a non-empty id, pending status, zero counts, and a recent CreatedUtc.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When retrieving an existing join, then GetJoinAsync returns it.",
      "intent": "Verify joins can be fetched by id.",
      "scenario": "Given a join created via CreateJoinAsync.",
      "behavior": "The retrieved join matches the created JoinId and ExpectedSteps.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 116,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When retrieving a non-existent join, then GetJoinAsync returns null.",
      "intent": "Verify unknown join ids are handled gracefully.",
      "scenario": "Given a randomly generated JoinIdentifier.",
      "behavior": "The retrieved join is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 138,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join has multiple attached messages, then GetJoinMessagesAsync returns all ids.",
      "intent": "Verify join message enumeration returns every attached message.",
      "scenario": "Given a join with three attached outbox messages.",
      "behavior": "The returned list contains all three message ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 309,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IncrementCompletedAsync is called twice for the same message, then counts are not duplicated.",
      "intent": "Verify completion increments are idempotent per message.",
      "scenario": "Given a join with one attached message completed twice.",
      "behavior": "CompletedSteps remains 1 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 422,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When completed steps would exceed expected, then counts do not overrun expected steps.",
      "intent": "Verify completion counting is capped at ExpectedSteps.",
      "scenario": "Given a join expecting two steps with three attached messages completed.",
      "behavior": "CompletedSteps remains at 2 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 472,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When incrementing completion for an attached message, then CompletedSteps increases.",
      "intent": "Verify completion updates counters and timestamps.",
      "scenario": "Given a join with an attached message.",
      "behavior": "CompletedSteps is 1, FailedSteps is 0, and LastUpdatedUtc advances.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 225,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IncrementFailedAsync is called twice for the same message, then counts are not duplicated.",
      "intent": "Verify failure increments are idempotent per message.",
      "scenario": "Given a join with one attached message failed twice.",
      "behavior": "FailedSteps remains 1 and CompletedSteps remains 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 447,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When incrementing failure for an attached message, then FailedSteps increases.",
      "intent": "Verify failure updates counters and timestamps.",
      "scenario": "Given a join with an attached message.",
      "behavior": "FailedSteps is 1, CompletedSteps is 0, and LastUpdatedUtc advances.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 254,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages are acked, then join completion counts are incremented.",
      "intent": "Verify outbox acknowledgements report join completion automatically.",
      "scenario": "Given a join expecting two messages attached to the outbox.",
      "behavior": "CompletedSteps moves from 1 after the first ack to 2 after the second.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 507,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same message is acked multiple times, then join counts are not over-incremented.",
      "intent": "Verify outbox ack reporting is idempotent per message.",
      "scenario": "Given a join expecting one message that is acked twice.",
      "behavior": "CompletedSteps remains 1 and FailedSteps remains 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 578,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages fail, then join failure counts are incremented.",
      "intent": "Verify outbox failures report join failures automatically.",
      "scenario": "Given a join expecting two messages where one is acked and one fails.",
      "behavior": "CompletedSteps is 1 and FailedSteps is 1.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 545,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When UpdateStatusAsync sets a status, then the join status is updated.",
      "intent": "Verify status updates persist for joins.",
      "scenario": "Given a pending join that is updated to Completed.",
      "behavior": "The stored join status is Completed.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxJoinTests.cs",
        "line": 283,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then claimed sets do not overlap.",
      "intent": "Verify concurrent claims are exclusive per work item.",
      "scenario": "Given ten ready items and two workers claiming up to five each.",
      "behavior": "Claimed ids are disjoint and total claimed does not exceed ten.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 156,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to ack items, then item status is unchanged.",
      "intent": "Verify owner token enforcement for state changes.",
      "scenario": "Given claimed items owned by one token and an ack attempt with another token.",
      "behavior": "Status remains InProgress for the claimed items.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 180,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When abandoning claimed items with the correct owner, then they return to Ready.",
      "intent": "Verify abandon resets status for claimed items.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status returns to Ready for each claimed item.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 106,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acking claimed items with the correct owner, then they are marked done and processed.",
      "intent": "Verify acknowledgements update status and processing flags.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status becomes Done and IsProcessed is true for each claimed item.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 89,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When batch size is smaller than ready items, then ClaimAsync respects the limit.",
      "intent": "Verify ClaimAsync honors the requested batch size.",
      "scenario": "Given five ready outbox items and a batch size of two.",
      "behavior": "ClaimAsync returns exactly two ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 74,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ready items are available, then ClaimAsync returns their ids.",
      "intent": "Verify ready outbox work items can be claimed.",
      "scenario": "Given three ready outbox items and a new owner token.",
      "behavior": "ClaimAsync returns all three ids and they match the inserted items.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 57,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When failing claimed items with the correct owner, then they are marked Failed.",
      "intent": "Verify failure marks the work items as failed.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Status becomes Failed for each claimed item.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 122,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a claim expires, then ReapExpired returns items to Ready.",
      "intent": "Verify expired leases are reaped back to Ready.",
      "scenario": "Given a claimed item with a 1-second lease that is allowed to expire.",
      "behavior": "ReapExpiredAsync resets the item status to Ready.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkQueueTests.cs",
        "line": 138,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called manually, then items return to Ready.",
      "intent": "Verify manual abandon resets item status.",
      "scenario": "Given claimed items and the matching owner token.",
      "behavior": "Item status is Ready after abandon.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 124,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple concurrent claims run, then claimed ids are unique.",
      "intent": "Verify concurrency does not allow duplicate claims.",
      "scenario": "Given ten ready items and five concurrent claimers.",
      "behavior": "All claimed ids are unique and total claimed does not exceed ten.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 241,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When work-queue operations receive empty id lists, then they complete without error.",
      "intent": "Verify empty operations are handled gracefully.",
      "scenario": "Given empty id lists for AckAsync, AbandonAsync, and FailAsync.",
      "behavior": "The operations complete without throwing exceptions.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 226,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called repeatedly, then the operation is idempotent.",
      "intent": "Verify repeated acknowledgements leave the item done.",
      "scenario": "Given claimed items and multiple AckAsync calls by the owner.",
      "behavior": "Items remain in Done status.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 191,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease expires, then another owner can reclaim the item after reaping.",
      "intent": "Verify expired leases allow reclamation.",
      "scenario": "Given an item claimed with a 1-second lease, then reaped after expiry.",
      "behavior": "A second claim returns the same item id.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 142,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a claim is reaped, then the new owner token is recorded on reclaim.",
      "intent": "Verify owner tokens update when items are reclaimed after expiry.",
      "scenario": "Given an item claimed by owner1, expired, reaped, and reclaimed by owner2.",
      "behavior": "The OwnerToken stored for the item matches owner2.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 166,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to modify items, then status remains InProgress.",
      "intent": "Verify owner token enforcement for acknowledgements.",
      "scenario": "Given items claimed by owner1 and an ack attempt by owner2.",
      "behavior": "Item status stays InProgress.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 209,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When items are claimed, then they are marked InProgress.",
      "intent": "Verify claim operations update item status.",
      "scenario": "Given two ready outbox items and a claim call.",
      "behavior": "Claimed ids match the inserted items and their status is InProgress.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 103,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the worker processes claimed items, then it acknowledges them and marks them Done.",
      "intent": "Verify the worker processes and acknowledges all claimed items.",
      "scenario": "Given three ready outbox items and a running worker.",
      "behavior": "ProcessedItems contains all ids and their status is Done.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the worker is canceled, then it stops promptly.",
      "intent": "Verify cancellation short-circuits long processing delays.",
      "scenario": "Given a worker with a long processing delay and a cancellation token after one second.",
      "behavior": "StopAsync completes within five seconds.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 266,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When processing fails, then the worker abandons items back to Ready.",
      "intent": "Verify failures result in abandon rather than ack.",
      "scenario": "Given a worker configured to fail processing with two ready items.",
      "behavior": "Outbox items return to Ready status.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/OutboxWorkerTests.cs",
        "line": 82,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all identifier columns are queried together, then each property matches its inserted value.",
      "intent": "Confirm multi-column mapping across all identifier type handlers.",
      "scenario": "Given handlers are registered and one row contains each identifier value.",
      "behavior": "The projected record returns every identifier unchanged.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 318,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a DatabaseIdentifier is stored, then Dapper returns the same database id.",
      "intent": "Verify Dapper mapping for DatabaseIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with DatabaseIdColumn set.",
      "behavior": "The queried DatabaseIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 286,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an InboxMessageIdentifier is inserted, then Dapper reads the same identifier.",
      "intent": "Verify Dapper mapping for InboxMessageIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with InboxMessageIdColumn set.",
      "behavior": "The queried InboxMessageIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 126,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an InstanceIdentifier is stored, then Dapper reads the same instance id.",
      "intent": "Verify Dapper mapping for InstanceIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with InstanceIdColumn set.",
      "behavior": "The queried InstanceIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 254,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a JoinIdentifier is stored, then Dapper returns the same join id.",
      "intent": "Verify Dapper mapping for JoinIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with JoinIdColumn set.",
      "behavior": "The queried JoinIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a nullable OwnerToken is stored in a nullable column, then it is read back intact.",
      "intent": "Confirm nullable OwnerToken values are materialized correctly.",
      "scenario": "Given handlers are registered and a row is inserted with NullableOwnerTokenColumn set.",
      "behavior": "The nullable query result equals the inserted OwnerToken.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 93,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxMessageIdentifier is inserted, then Dapper returns the same identifier.",
      "intent": "Verify Dapper mapping for OutboxMessageIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with OutboxMessageIdColumn set.",
      "behavior": "The queried OutboxMessageIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 158,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxWorkItemIdentifier is stored, then Dapper reads it back unchanged.",
      "intent": "Verify Dapper mapping for OutboxWorkItemIdentifier UUIDs.",
      "scenario": "Given handlers are registered and a row is inserted with OutboxWorkItemIdColumn set.",
      "behavior": "The queried OutboxWorkItemIdentifier matches the inserted value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 190,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a row is inserted with an OwnerToken, then Dapper returns the same token.",
      "intent": "Confirm the OwnerToken handler maps UUID values losslessly.",
      "scenario": "Given handlers are registered and a row is inserted with OwnerTokenColumn plus other GUID fields.",
      "behavior": "The OwnerToken query result matches the inserted token.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresDapperTypeHandlerTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.PostgresDapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called with a hash, then the hash is stored.",
      "intent": "Verify the message hash is persisted with the inbox row.",
      "scenario": "Given a message id/source and a byte[] hash passed to AlreadyProcessedAsync.",
      "behavior": "The stored Hash value matches the provided hash.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 196,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync receives a null or empty message id, then it throws ArgumentException.",
      "intent": "Verify invalid message ids are rejected.",
      "scenario": "Given null or empty messageId inputs.",
      "behavior": "AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync receives a null or empty source, then it throws ArgumentException.",
      "intent": "Verify invalid sources are rejected.",
      "scenario": "Given null or empty source inputs.",
      "behavior": "AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 237,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called for a new message, then it returns false and records the row.",
      "intent": "Verify new messages are inserted and reported as not processed.",
      "scenario": "Given a PostgresInboxService and a new message id/source.",
      "behavior": "AlreadyProcessedAsync returns false and one inbox row exists for the message id.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 39,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message has been marked processed, then AlreadyProcessedAsync returns true.",
      "intent": "Verify processed messages are detected as already processed.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync and then marked processed.",
      "behavior": "A subsequent AlreadyProcessedAsync call returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 64,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple AlreadyProcessedAsync calls run concurrently, then one row exists with attempts tracked.",
      "intent": "Verify concurrent checks create a single inbox row and increment attempts.",
      "scenario": "Given five concurrent AlreadyProcessedAsync calls for the same message id.",
      "behavior": "All calls return false, one row exists, and Attempts equals 5.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 159,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkDeadAsync_UpdatesStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkDeadAsync is called, then Status becomes Dead.",
      "intent": "Verify MarkDeadAsync marks messages as dead.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "The inbox row Status is Dead.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 134,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkDeadAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessedAsync is called, then ProcessedUtc is set and Status is Done.",
      "intent": "Verify MarkProcessedAsync updates completion fields.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "ProcessedUtc is non-null and Status is Done in the inbox row.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 83,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkProcessingAsync_UpdatesStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessingAsync is called, then Status becomes Processing.",
      "intent": "Verify MarkProcessingAsync moves the message into processing state.",
      "scenario": "Given a message recorded via AlreadyProcessedAsync.",
      "behavior": "The inbox row Status is Processing.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresInboxServiceTests.cs",
        "line": 109,
        "member": "Bravellian.Platform.Tests.PostgresInboxServiceTests.MarkProcessingAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an available lease is acquired, then a runner is returned with valid state.",
      "intent": "Verify a new lease acquisition initializes runner identity and state.",
      "scenario": "Given a new lease name, owner, and a fake monotonic clock.",
      "behavior": "The runner is not lost, reflects the lease name/owner, and has an un-canceled token.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 50,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second acquisition attempt returns null.",
      "intent": "Confirm unavailable leases are not re-acquired by another owner.",
      "scenario": "Given owner1 holds the lease and owner2 attempts to acquire the same lease.",
      "behavior": "The second acquisition returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 85,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.DisposedRunner_DoesNotRenew",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a runner is disposed, then TryRenewNowAsync returns false.",
      "intent": "Verify renewal requests are rejected after disposal.",
      "scenario": "Given a runner that has been acquired and then disposed.",
      "behavior": "TryRenewNowAsync returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 238,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.DisposedRunner_DoesNotRenew"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewal is scheduled at 50% of the lease duration, then the runner stays valid past the midpoint.",
      "intent": "Confirm monotonic renewal timing honors a custom renew percentage.",
      "scenario": "Given a 10-second lease and renewPercent set to 0.5.",
      "behavior": "After waiting past the midpoint, IsLost is false and cancellation is not requested.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 200,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.RenewTimer_UsesFakeMonotonicClockAcrossClockSkewAndGcPauses",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the monotonic clock jumps forward, then renewal scheduling advances using monotonic time.",
      "intent": "Validate renewal scheduling resilience to wall-clock skew and GC pauses.",
      "scenario": "Given a runner with a fake monotonic clock and access to the internal renew timer callback.",
      "behavior": "The next renew time advances with monotonic time and remains unchanged on immediate retry.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 271,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.RenewTimer_UsesFakeMonotonicClockAcrossClockSkewAndGcPauses"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Given a valid lease runner, then ThrowIfLost does not throw.",
      "intent": "Confirm loss checks are no-ops while the lease is valid.",
      "scenario": "Given a runner acquired with a 30-second lease duration.",
      "behavior": "ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 168,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresLeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a valid runner renews, then TryRenewNowAsync succeeds and the runner remains valid.",
      "intent": "Verify manual renewal keeps the lease active.",
      "scenario": "Given a runner acquired for a new lease name and owner.",
      "behavior": "TryRenewNowAsync returns true and IsLost stays false.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/LeaseRunnerTests.cs",
        "line": 132,
        "member": "Bravellian.Platform.Tests.PostgresLeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.Constructor_CreatesInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When constructed with valid options, then the service is created and implements IOutbox.",
      "intent": "Verify the outbox service can be instantiated with valid options.",
      "scenario": "Given PostgresOutboxOptions and a null logger instance.",
      "behavior": "The instance is non-null and assignable to IOutbox.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 50,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.Constructor_CreatesInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple messages are enqueued in a transaction, then all rows are inserted.",
      "intent": "Verify batch enqueues insert all messages within the transaction.",
      "scenario": "Given three enqueue calls in the same transaction.",
      "behavior": "The outbox table contains three rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 199,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue runs with schema deployment enabled, then it creates the table and inserts the row.",
      "intent": "Verify schema deployment ensures the outbox table exists before enqueue.",
      "scenario": "Given a custom schema/table with EnableSchemaDeployment true and the table dropped.",
      "behavior": "The custom outbox table is created and contains the enqueued message.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 339,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple standalone enqueue calls are made, then all rows are inserted.",
      "intent": "Verify multiple standalone enqueues insert all messages.",
      "scenario": "Given three distinct topics/payloads enqueued without a transaction.",
      "behavior": "The outbox table contains three matching rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 302,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue uses a null correlation id, then the message is inserted.",
      "intent": "Verify standalone enqueue handles null correlation ids.",
      "scenario": "Given a topic and payload with a null correlation id.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 272,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When using standalone enqueue, then the message is inserted with the correlation id.",
      "intent": "Verify standalone enqueue persists messages without an explicit transaction.",
      "scenario": "Given a topic, payload, and correlation id.",
      "behavior": "The outbox table contains one row matching the topic, payload, and correlation id.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 240,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When using a custom schema and table, then EnqueueAsync inserts into the custom table.",
      "intent": "Verify custom schema/table options are honored by enqueue.",
      "scenario": "Given a custom outbox service and a transaction scoped to the custom table.",
      "behavior": "The custom outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 92,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync is called with a null correlation id, then the message is inserted.",
      "intent": "Verify null correlation ids do not block insertion.",
      "scenario": "Given a transaction and a message with a null correlation id.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 133,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync receives a null transaction, then it throws ArgumentNullException.",
      "intent": "Verify EnqueueAsync validates the transaction argument.",
      "scenario": "Given a null IDbTransaction argument.",
      "behavior": "EnqueueAsync throws ArgumentNullException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 223,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync is called in a transaction, then a message row is inserted.",
      "intent": "Verify transactional enqueue inserts a row with topic and payload.",
      "scenario": "Given an open connection, a transaction, and topic/payload/correlation id values.",
      "behavior": "The outbox table contains one row matching the topic and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 63,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueAsync inserts a message, then default fields are set.",
      "intent": "Verify default outbox values are populated on insert.",
      "scenario": "Given a new message enqueued in a transaction.",
      "behavior": "IsProcessed is false, ProcessedAt is null, RetryCount is 0, CreatedAt is recent, and MessageId is set.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxServiceTests.cs",
        "line": 161,
        "member": "Bravellian.Platform.Tests.PostgresOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithDueMessages_ReturnsMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a ready message is due, then ClaimDueAsync returns it.",
      "intent": "Verify due messages are claimed.",
      "scenario": "Given one ready message with a past CreatedAt and no future DueTimeUtc.",
      "behavior": "The claimed list contains the message with expected id, topic, and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 66,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithDueMessages_ReturnsMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithFutureMessages_ReturnsEmpty",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is scheduled in the future, then ClaimDueAsync returns empty.",
      "intent": "Verify future-due messages are not claimed early.",
      "scenario": "Given a ready message with DueTimeUtc set in the future.",
      "behavior": "The claimed message list is empty.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 101,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithFutureMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithNoMessages_ReturnsEmptyList",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no messages are due, then ClaimDueAsync returns an empty list.",
      "intent": "Verify empty outboxes yield no claims.",
      "scenario": "Given an outbox table with no rows.",
      "behavior": "The claimed message list is empty.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 54,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.ClaimDueAsync_WithNoMessages_ReturnsEmptyList"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.FailAsync_MarksMessageAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called, then the message is marked failed with an error.",
      "intent": "Verify permanent failure updates status and error fields.",
      "scenario": "Given a claimed message and a failure reason.",
      "behavior": "Status becomes Failed, LastError is set, and ProcessedBy indicates failure.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.FailAsync_MarksMessageAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.MarkDispatchedAsync_UpdatesMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkDispatchedAsync is called, then the message is marked done and processed.",
      "intent": "Verify dispatch updates status and IsProcessed flags.",
      "scenario": "Given a claimed outbox message.",
      "behavior": "Status becomes Done and IsProcessed is true for the message row.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 134,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.MarkDispatchedAsync_UpdatesMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresOutboxStoreTests.RescheduleAsync_UpdatesRetryCountAndNextAttempt",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When RescheduleAsync is called, then RetryCount increments and the error is recorded.",
      "intent": "Verify rescheduling records errors and bumps retry count.",
      "scenario": "Given a claimed message with RetryCount 2 and a reschedule delay.",
      "behavior": "RetryCount becomes 3, LastError is set, and Status is Ready.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresOutboxStoreTests.cs",
        "line": 176,
        "member": "Bravellian.Platform.Tests.PostgresOutboxStoreTests.RescheduleAsync_UpdatesRetryCountAndNextAttempt"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When constructed with valid options, then the client is created and implements ISchedulerClient.",
      "intent": "Verify the scheduler client can be instantiated with valid options.",
      "scenario": "Given PostgresSchedulerOptions with a valid connection string.",
      "behavior": "The instance is non-null and assignable to ISchedulerClient.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When updating an existing job, then the job is updated without duplication.",
      "intent": "Verify CreateOrUpdateJobAsync updates existing jobs.",
      "scenario": "Given a job created once and then updated with a new topic.",
      "behavior": "The Jobs table has one row and the topic matches the update.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 183,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_NewJob_InsertsJob",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When creating a new job, then a job row is inserted.",
      "intent": "Verify CreateOrUpdateJobAsync inserts new jobs.",
      "scenario": "Given a job name, topic, and cron schedule that do not yet exist.",
      "behavior": "The Jobs table contains one row for the job name.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 137,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_NewJob_InsertsJob"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_SetsPayloadToNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a job is created without a payload, then the payload column is null.",
      "intent": "Verify null payloads are persisted as NULL.",
      "scenario": "Given CreateOrUpdateJobAsync called without a payload for a new job.",
      "behavior": "The Jobs row payload column is NULL.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_SetsPayloadToNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When deleting a job by name, then the job row is removed.",
      "intent": "Verify DeleteJobAsync removes jobs.",
      "scenario": "Given a job created and then deleted by name.",
      "behavior": "The Jobs table contains zero rows for the job name.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 216,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When scheduling with custom table names, then the timer is inserted into the custom table.",
      "intent": "Verify custom schema/table names are honored for timers.",
      "scenario": "Given a scheduler client configured with custom schema and table names.",
      "behavior": "The custom timers table contains one row for the scheduled timer.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 92,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then a timer row is inserted into the database.",
      "intent": "Verify ScheduleTimerAsync persists timers to the Timers table.",
      "scenario": "Given a topic, payload, and due time in the near future.",
      "behavior": "The Timers table contains one row for the returned timer id and topic.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 65,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.PostgresSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When triggering a job by name, then a job run row is created.",
      "intent": "Verify TriggerJobAsync creates job runs.",
      "scenario": "Given an existing job and a trigger call.",
      "behavior": "The JobRuns table contains at least one row for the job.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/PostgresSchedulerClientTests.cs",
        "line": 241,
        "member": "Bravellian.Platform.Tests.PostgresSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentReapAndAcquire_MaintainsCorrectness",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When reaping and acquiring occur concurrently, then deletions and acquires stay within limits.",
      "intent": "Verify concurrent reaping and acquisition maintains correctness.",
      "scenario": "Given three expired leases, a reap task, and concurrent acquire attempts up to the limit.",
      "behavior": "Deleted count is at most 3 and acquired count does not exceed the limit.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 261,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentReapAndAcquire_MaintainsCorrectness"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentUpdateLimit_DoesNotCorruptState",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When limits are updated concurrently, then state remains usable for acquiring.",
      "intent": "Verify concurrent limit updates do not corrupt semaphore state.",
      "scenario": "Given multiple concurrent UpdateLimitAsync calls with different values.",
      "behavior": "A subsequent TryAcquireAsync returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentUpdateLimit_DoesNotCorruptState"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.FencingCounters_StrictlyIncreasingUnderConcurrency",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring concurrently, then fencing counters are unique and strictly increasing.",
      "intent": "Verify fencing counters remain monotonic under concurrency.",
      "scenario": "Given 20 concurrent acquire attempts on a semaphore with limit 20.",
      "behavior": "The fencing counters are unique and strictly increasing when ordered.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 318,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.FencingCounters_StrictlyIncreasingUnderConcurrency"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.HighContentionAcquire_EventuallySucceeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquisitions retry under high contention, then most workers eventually succeed.",
      "intent": "Verify retry loops allow progress under contention.",
      "scenario": "Given limit 2, 10 workers, and up to 15 retries with short TTLs.",
      "behavior": "More than half of the workers eventually acquire the semaphore.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 172,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.HighContentionAcquire_EventuallySucceeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquireAndRelease_MaintainsInvariant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When workers acquire and release in parallel, then every successful acquire is released.",
      "intent": "Verify acquire/release concurrency preserves invariants.",
      "scenario": "Given limit 5 and 20 workers that acquire, hold briefly, and release.",
      "behavior": "The count of successful releases equals the count of successful acquires.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 114,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquireAndRelease_MaintainsInvariant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquires_NeverExceedsLimit",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When many workers acquire in parallel, then successes never exceed the limit.",
      "intent": "Verify concurrent acquisitions respect the configured capacity.",
      "scenario": "Given limit 10 and 50 parallel acquire attempts.",
      "behavior": "The acquired count is greater than zero and no more than the limit.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 67,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquires_NeverExceedsLimit"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.Renewals_WithIntermittentGcPausesMaintainLeases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewals run with jitter and pauses, then leases remain renewed.",
      "intent": "Verify renewals succeed despite intermittent delays.",
      "scenario": "Given three acquired leases renewed multiple times with jitter and a simulated pause.",
      "behavior": "All renewal results return Renewed.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 363,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.Renewals_WithIntermittentGcPausesMaintainLeases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.StarvedAcquisition_AppliesBackpressureUntilCapacityReturns",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When capacity is saturated, then contenders see NotAcquired until capacity returns.",
      "intent": "Verify backpressure occurs while a semaphore slot is held.",
      "scenario": "Given limit 1, a holder lease, and contenders polling for acquisition.",
      "behavior": "NotAcquired counts increase and acquisition succeeds after release.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreConcurrencyTests.cs",
        "line": 431,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.StarvedAcquisition_AppliesBackpressureUntilCapacityReturns"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitAboveMaximum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnsureExists is called with a limit above maximum, then it throws ArgumentException.",
      "intent": "Verify semaphore limit upper bound validation.",
      "scenario": "Given a limit value of 10001.",
      "behavior": "EnsureExistsAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 750,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitAboveMaximum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitBelowMinimum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnsureExists is called with a limit below minimum, then it throws ArgumentException.",
      "intent": "Verify semaphore limit lower bound validation.",
      "scenario": "Given a limit value of 0.",
      "behavior": "EnsureExistsAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 732,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitBelowMinimum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Fencing_StrictlyIncreases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring sequentially, then fencing counters strictly increase.",
      "intent": "Verify fencing tokens are monotonically increasing for each acquisition.",
      "scenario": "Given five successive acquire calls for the same semaphore.",
      "behavior": "Each fencing counter is greater than the previous one.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 287,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Fencing_StrictlyIncreases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.MultipleNames_AreIsolated",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring different semaphore names, then each name is isolated.",
      "intent": "Verify independent capacity for different semaphore names.",
      "scenario": "Given two distinct semaphore names, each ensured with limit 1.",
      "behavior": "Both acquires succeed with different tokens.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 772,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.MultipleNames_AreIsolated"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_RemovesExpiredLeases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ReapExpired runs after expiry, then expired leases are deleted.",
      "intent": "Verify reaping removes expired lease rows.",
      "scenario": "Given three short-lived leases that have expired.",
      "behavior": "ReapExpired deletes three rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 386,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_RemovesExpiredLeases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_WithMaxRows_LimitsDeletions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ReapExpired uses maxRows, then deletions are capped.",
      "intent": "Verify maxRows limits the number of deleted rows per reaper run.",
      "scenario": "Given five expired leases and a reap call with maxRows set to 2.",
      "behavior": "The first reap deletes 2 rows and the subsequent reap deletes the remaining 3.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 420,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_WithMaxRows_LimitsDeletions"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Release_FreesCapacity",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then capacity becomes available for another acquire.",
      "intent": "Verify release frees a slot for a new owner.",
      "scenario": "Given a semaphore with limit 1 and one acquired token that is released.",
      "behavior": "Release returns Released and the next acquire succeeds.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 152,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Release_FreesCapacity"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Release_IdempotentWhenCalledTwice",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same token is released twice, then the second release reports NotFound.",
      "intent": "Verify releases are idempotent for the same token.",
      "scenario": "Given a semaphore token released twice.",
      "behavior": "The first release is Released and the second is NotFound.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 188,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Release_IdempotentWhenCalledTwice"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_AfterRelease_ReturnsLost",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing after a release, then the renewal returns Lost.",
      "intent": "Verify renew fails once the lease has been released.",
      "scenario": "Given an acquired token that has been released before renew.",
      "behavior": "The renew result status is Lost.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 254,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_AfterRelease_ReturnsLost"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_ExtendsLeaseExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing a valid token, then the expiry is extended.",
      "intent": "Verify renew updates ExpiresAtUtc for active leases.",
      "scenario": "Given an acquired token that is renewed after a short delay.",
      "behavior": "Renew returns Renewed and ExpiresAtUtc is later than the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 221,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_ExtendsLeaseExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_MonotonicExtension_NeverShortensExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing with a shorter TTL, then expiry is not shortened.",
      "intent": "Verify renewal does not reduce the existing expiration time.",
      "scenario": "Given a lease acquired with a 60-second TTL and renewed with 10 seconds.",
      "behavior": "The renew result is Renewed and ExpiresAtUtc is not earlier than the original expiry.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 317,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_MonotonicExtension_NeverShortensExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_AfterExpiry_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease expires, then a new acquire succeeds.",
      "intent": "Verify expired leases free capacity for new owners.",
      "scenario": "Given a semaphore acquired with a short TTL that is allowed to expire.",
      "behavior": "The subsequent acquire returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 352,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_AfterExpiry_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_BeyondLimit_ReturnsNotAcquired",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring beyond the limit, then the extra acquire returns NotAcquired.",
      "intent": "Verify acquisitions beyond capacity are rejected.",
      "scenario": "Given a semaphore with limit 2 already fully acquired.",
      "behavior": "The extra acquire result status is NotAcquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_BeyondLimit_ReturnsNotAcquired"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidNameCharacters_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name has invalid characters, then TryAcquire throws ArgumentException.",
      "intent": "Verify disallowed characters are rejected.",
      "scenario": "Given semaphore names containing spaces or forbidden symbols.",
      "behavior": "TryAcquireAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 675,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidNameCharacters_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidName_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When TryAcquire is called with a blank name, then it throws ArgumentException.",
      "intent": "Verify semaphore name validation rejects empty or whitespace names.",
      "scenario": "Given empty or whitespace semaphore names.",
      "behavior": "TryAcquireAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 609,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidName_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_NameTooLong_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name exceeds the maximum length, then TryAcquire throws ArgumentException.",
      "intent": "Verify name length validation for semaphore operations.",
      "scenario": "Given a semaphore name longer than 200 characters.",
      "behavior": "TryAcquireAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 626,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_NameTooLong_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlAboveMaximum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ttlSeconds exceeds the maximum, then TryAcquire throws ArgumentException.",
      "intent": "Verify TTL upper bound enforcement.",
      "scenario": "Given ttlSeconds set to 3601.",
      "behavior": "TryAcquireAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 712,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlAboveMaximum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlBelowMinimum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ttlSeconds is below the minimum, then TryAcquire throws ArgumentException.",
      "intent": "Verify TTL lower bound enforcement.",
      "scenario": "Given ttlSeconds set to 0.",
      "behavior": "TryAcquireAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 692,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlBelowMinimum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_UpToLimit_AllAcquiresSucceed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring up to the semaphore limit, then all acquires succeed.",
      "intent": "Verify capacity enforcement allows up to the configured limit.",
      "scenario": "Given a semaphore with limit 3 and three acquire attempts.",
      "behavior": "All results are Acquired with unique tokens and fencing counters.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 89,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_UpToLimit_AllAcquiresSucceed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_ValidNameCharacters_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name uses allowed characters, then TryAcquire succeeds.",
      "intent": "Verify allowed name characters are accepted.",
      "scenario": "Given valid semaphore names that are ensured and acquired.",
      "behavior": "The acquire result status is Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 651,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_ValidNameCharacters_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithNonExistentSemaphore_ReturnsNotAcquired",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When TryAcquire is called for a non-existent semaphore, then it returns NotAcquired.",
      "intent": "Verify acquisition fails if the semaphore has not been created.",
      "scenario": "Given a random semaphore name with no prior EnsureExistsAsync call.",
      "behavior": "The acquire result status is NotAcquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 68,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithNonExistentSemaphore_ReturnsNotAcquired"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithSameClientRequestId_ReturnsExistingLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same clientRequestId is reused, then TryAcquire returns the existing lease.",
      "intent": "Verify idempotent acquisition by client request id.",
      "scenario": "Given two TryAcquire calls with the same clientRequestId.",
      "behavior": "The second result matches the first token and fencing counter.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 568,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithSameClientRequestId_ReturnsExistingLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Decrease_BlocksNewAcquires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the limit is decreased below the active count, then new acquires are blocked.",
      "intent": "Verify limit decreases enforce the new capacity immediately.",
      "scenario": "Given two active leases and a limit reduced to one.",
      "behavior": "Acquires remain NotAcquired until the active count drops below the new limit.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 501,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Decrease_BlocksNewAcquires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Increase_EnablesMoreAcquires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the limit is increased, then additional acquires succeed.",
      "intent": "Verify limit increases open capacity for new leases.",
      "scenario": "Given a semaphore at limit 1 with one active lease, then limit raised to 2.",
      "behavior": "The next acquire returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SemaphoreServiceTests.cs",
        "line": 465,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Increase_EnablesMoreAcquires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then acquiring the resource again succeeds.",
      "intent": "Verify release allows a new lease with a higher fencing token.",
      "scenario": "Given a resource acquired, disposed, and then acquired again.",
      "behavior": "The second lease is non-null with a fencing token greater than the first.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 107,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring the same resource with the same owner token, then both acquisitions succeed.",
      "intent": "Verify reentrant acquisition with the same owner token is permitted.",
      "scenario": "Given two AcquireAsync calls for the same resource using the same owner token.",
      "behavior": "Both leases are non-null and the second fencing token exceeds the first.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 237,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring the same resource twice, then the second call returns null.",
      "intent": "Verify lease acquisition is exclusive per resource.",
      "scenario": "Given one resource acquired and a second acquisition attempt for the same resource.",
      "behavior": "The second acquisition returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 84,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring with a custom owner token, then the lease uses the provided token.",
      "intent": "Verify caller-supplied owner tokens are honored.",
      "scenario": "Given a custom OwnerToken and a new resource name.",
      "behavior": "The acquired lease reports the provided owner token.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 212,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring leases for different resources, then both acquisitions succeed.",
      "intent": "Verify resource isolation across independent leases.",
      "scenario": "Given two distinct resource names and one lease factory.",
      "behavior": "Both leases are non-null with different resource names and owner tokens.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 184,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring a lease for a valid resource, then a lease is returned with expected metadata.",
      "intent": "Verify successful lease acquisition populates owner and fencing tokens.",
      "scenario": "Given a PostgresLeaseFactory, a new resource name, and a 30-second lease duration.",
      "behavior": "The lease is non-null with the resource name, non-empty owner token, and active cancellation token.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 59,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is valid, then ThrowIfLost does not throw.",
      "intent": "Verify loss checks are no-ops for active leases.",
      "scenario": "Given a lease acquired for a resource.",
      "behavior": "ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 163,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Postgres.Tests:Bravellian.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on a valid lease, then it succeeds and increments the fencing token.",
      "intent": "Verify renewal updates fencing token for a held lease.",
      "scenario": "Given a lease acquired for a resource with a 30-second duration.",
      "behavior": "TryRenewNowAsync returns true and the fencing token increases.",
      "source": {
        "file": "tests/Bravellian.Platform.Postgres.Tests/SystemLeaseTests.cs",
        "line": 136,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Postgres.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.BuilderRegistersCachedCheck_WithOptionsPerName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a cached check is registered with per-name options, then the configured cache durations are honored.",
      "intent": "Ensure AddCachedCheck applies custom options for the named check.",
      "scenario": "Given a ServiceCollection with a FakeTimeProvider and a CountingHealthCheck registered via AddCachedCheck.",
      "behavior": "Then repeated health checks within the cache window do not re-invoke the inner check.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 152,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.BuilderRegistersCachedCheck_WithOptionsPerName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.BuilderRegistersDelegateBasedCachedCheck_WithCaching",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a delegate-based cached check is registered, then caching reduces delegate invocations.",
      "intent": "Validate AddCachedCheck with a delegate honors the healthy cache duration.",
      "scenario": "Given a cached check delegate that increments a counter and a FakeTimeProvider.",
      "behavior": "Then three health checks result in two delegate invocations after time advances.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 196,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.BuilderRegistersDelegateBasedCachedCheck_WithCaching"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.CachesDegradedResults_UntilDurationExpires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a degraded result is cached, then repeated checks within the degraded cache window reuse the result.",
      "intent": "Verify degraded results are cached for the configured duration.",
      "scenario": "Given a CachedHealthCheck with a FakeTimeProvider and a CountingHealthCheck returning Degraded.",
      "behavior": "Then the inner check runs twice across three calls as time advances past the cache duration.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 116,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.CachesDegradedResults_UntilDurationExpires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.CachesHealthyResults_UntilDurationExpires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a healthy result is cached, then repeated checks within the cache window reuse the result.",
      "intent": "Verify healthy results are cached for the configured duration.",
      "scenario": "Given a CachedHealthCheck with a FakeTimeProvider and a CountingHealthCheck returning Healthy.",
      "behavior": "Then the inner check runs twice across three calls separated by time advances.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 40,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.CachesHealthyResults_UntilDurationExpires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_AcceptsValidOptions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cache durations are non-negative, then validation succeeds.",
      "intent": "Confirm valid CachedHealthCheckOptions pass validation.",
      "scenario": "Given options with positive healthy/degraded durations and zero unhealthy duration.",
      "behavior": "Then validation succeeds.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 308,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_AcceptsValidOptions"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeDegradedCacheDuration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When DegradedCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative degraded cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative DegradedCacheDuration.",
      "behavior": "Then validation fails and references DegradedCacheDuration in the message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 262,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeDegradedCacheDuration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeHealthyCacheDuration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When HealthyCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative healthy cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative HealthyCacheDuration.",
      "behavior": "Then validation fails and references HealthyCacheDuration in the message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 239,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeHealthyCacheDuration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeUnhealthyCacheDuration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When UnhealthyCacheDuration is negative, then validation fails.",
      "intent": "Enforce non-negative unhealthy cache durations.",
      "scenario": "Given CachedHealthCheckOptions with a negative UnhealthyCacheDuration.",
      "behavior": "Then validation fails and references UnhealthyCacheDuration in the message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 285,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.OptionsValidator_RejectsNegativeUnhealthyCacheDuration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CachedHealthCheckTests.RechecksImmediately_WhenUnhealthy",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an unhealthy result is returned with zero unhealthy cache duration, then the next check re-evaluates immediately.",
      "intent": "Ensure unhealthy results do not get cached when configured for immediate rechecks.",
      "scenario": "Given a SequenceHealthCheck that returns Unhealthy then Healthy with UnhealthyCacheDuration set to zero.",
      "behavior": "Then the second call invokes the inner check again and returns Healthy.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CachedHealthCheckTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.CachedHealthCheckTests.RechecksImmediately_WhenUnhealthy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_CreatesFactoriesFromConfigsAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When lease factory configs are provided, then the provider creates a factory for each configuration.",
      "intent": "Verify configured provider materializes lease factories from config entries.",
      "scenario": "Given two LeaseDatabaseConfig entries and a test logger factory.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers matching the configs.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 45,
        "member": "Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_CreatesFactoriesFromConfigsAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryByKey_ReturnsCorrectFactoryAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a factory is requested by key, then the provider returns the matching factory or null.",
      "intent": "Ensure key-based lookup resolves known factories and rejects unknown keys.",
      "scenario": "Given two LeaseDatabaseConfig entries and a ConfiguredLeaseFactoryProvider instance.",
      "behavior": "Then known keys return factories with matching identifiers and an unknown key returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 84,
        "member": "Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryByKey_ReturnsCorrectFactoryAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryIdentifier_ReturnsUnknownForInvalidFactory",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a factory not created by the provider is inspected, then its identifier is reported as \u0022Unknown\u0022.",
      "intent": "Confirm identifier lookup only recognizes provider-managed factories.",
      "scenario": "Given an external SqlLeaseFactory not created by ConfiguredLeaseFactoryProvider.",
      "behavior": "Then GetFactoryIdentifier returns \u0022Unknown\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ConfiguredLeaseFactoryProviderTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.ConfiguredLeaseFactoryProviderTests.ConfiguredProvider_GetFactoryIdentifier_ReturnsUnknownForInvalidFactory"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_OldSignature_StillWorks",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the obsolete discovery-based control plane overload is used, then it still wires defaults correctly.",
      "intent": "Ensure legacy discovery registration continues to configure the control plane schema.",
      "scenario": "Given AddPlatformMultiDatabaseWithControlPlaneAndDiscovery called via the obsolete signature and a list-based discovery.",
      "behavior": "Then PlatformConfiguration and SemaphoreOptions default the schema to \u0022infra\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ControlPlaneConfigurationTests.cs",
        "line": 209,
        "member": "Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_OldSignature_StillWorks"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_WithOptions_ConfiguresSchemaName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based control plane registration specifies a schema name, then configuration and semaphore options use it.",
      "intent": "Verify control-plane settings flow through discovery-based registration.",
      "scenario": "Given AddPlatformMultiDatabaseWithControlPlaneAndDiscovery with a ListBasedDatabaseDiscovery and custom SchemaName.",
      "behavior": "Then PlatformConfiguration reflects the schema and semaphore options use the same values.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ControlPlaneConfigurationTests.cs",
        "line": 89,
        "member": "Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_WithOptions_ConfiguresSchemaName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndList_OldSignature_StillWorks",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the obsolete list-based control plane overload is used, then it still wires defaults correctly.",
      "intent": "Ensure legacy registration paths continue to configure the control plane schema.",
      "scenario": "Given AddPlatformMultiDatabaseWithControlPlaneAndList called via the obsolete signature.",
      "behavior": "Then PlatformConfiguration and SemaphoreOptions default the schema to \u0022infra\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ControlPlaneConfigurationTests.cs",
        "line": 165,
        "member": "Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndList_OldSignature_StillWorks"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndList_WithOptions_ConfiguresSchemaName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based control plane registration specifies a schema name, then configuration and semaphore options use it.",
      "intent": "Verify control-plane schema settings are propagated to configuration and semaphore options.",
      "scenario": "Given AddPlatformMultiDatabaseWithControlPlaneAndList called with control plane options specifying SchemaName = \u0022control\u0022.",
      "behavior": "Then PlatformConfiguration and SemaphoreOptions use the control plane schema and connection string.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ControlPlaneConfigurationTests.cs",
        "line": 39,
        "member": "Bravellian.Platform.Tests.ControlPlaneConfigurationTests.AddPlatformMultiDatabaseWithControlPlaneAndList_WithOptions_ConfiguresSchemaName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ControlPlaneConfigurationTests.PlatformControlPlaneOptions_DefaultSchemaName_IsDbo",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When PlatformControlPlaneOptions is created without a schema name, then it defaults to \u0022infra\u0022.",
      "intent": "Confirm control-plane options default schema aligns with platform conventions.",
      "scenario": "Given a PlatformControlPlaneOptions instance with only ConnectionString set.",
      "behavior": "Then SchemaName is \u0022infra\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ControlPlaneConfigurationTests.cs",
        "line": 142,
        "member": "Bravellian.Platform.Tests.ControlPlaneConfigurationTests.PlatformControlPlaneOptions_DefaultSchemaName_IsDbo"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the distributed lock schema is ensured with a custom schema, then all lock objects are created under that schema.",
      "intent": "Verify distributed lock tables and procedures honor a non-default schema name.",
      "scenario": "Given EnsureDistributedLockSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the DistributedLock table and Lock_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 48,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureDistributedLockSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the fanout schema is ensured with a custom schema, then fanout tables are created under that schema.",
      "intent": "Verify fanout schema deployment respects custom schema configuration.",
      "scenario": "Given EnsureFanoutSchemaAsync called with the CustomSchema value.",
      "behavior": "Then FanoutPolicy and FanoutCursor tables exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 310,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureFanoutSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox schema is ensured with a custom schema, then the inbox table is created under that schema.",
      "intent": "Verify inbox schema deployment uses the configured schema name.",
      "scenario": "Given EnsureInboxSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Inbox table exists in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 152,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox work queue schema is ensured with a custom schema, then inbox work-queue objects are created there.",
      "intent": "Verify inbox work queue deployment uses custom schema names after inbox setup.",
      "scenario": "Given an inbox table exists and EnsureInboxWorkQueueSchemaAsync is run with the CustomSchema value.",
      "behavior": "Then the StringIdList type and Inbox_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 263,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureInboxWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the lease schema is ensured with a custom schema, then lease tables and procedures are created under that schema.",
      "intent": "Verify lease schema deployment respects custom schema names.",
      "scenario": "Given EnsureLeaseSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Lease table and Lease_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 88,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureLeaseSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the outbox schema is ensured with a custom schema, then outbox tables are created under that schema.",
      "intent": "Verify outbox table deployment honors custom schema configuration.",
      "scenario": "Given EnsureOutboxSchemaAsync called with the CustomSchema value.",
      "behavior": "Then the Outbox and OutboxState tables exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 122,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureOutboxSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the scheduler schema is ensured with a custom schema, then scheduler tables are created under that schema.",
      "intent": "Verify scheduler schema deployment honors custom schema names.",
      "scenario": "Given EnsureSchedulerSchemaAsync called with the CustomSchema value.",
      "behavior": "Then Jobs, Timers, JobRuns, and SchedulerState tables exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 179,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureSchedulerSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the work queue schema is ensured with a custom schema, then work-queue types and procedures are created there.",
      "intent": "Verify work queue deployment uses custom schema names after outbox setup.",
      "scenario": "Given an outbox table exists and EnsureWorkQueueSchemaAsync is run with the CustomSchema value.",
      "behavior": "Then the GuidIdList type and Outbox_* procedures exist in the custom schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/CustomSchemaIntegrationTests.cs",
        "line": 216,
        "member": "Bravellian.Platform.Tests.CustomSchemaIntegrationTests.EnsureWorkQueueSchema_WithCustomSchema_CreatesObjectsInCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all strongly-typed IDs are inserted in one row, then Dapper retrieves each value correctly.",
      "intent": "Validate multiple type handlers in a single query.",
      "scenario": "Given a test row containing OwnerToken and various identifier types.",
      "behavior": "Then each retrieved identifier matches its original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 451,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.AllTypesInSingleQuery_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a DatabaseIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for DatabaseIdentifier.",
      "scenario": "Given a test table and a generated DatabaseIdentifier value.",
      "behavior": "Then the retrieved DatabaseIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 407,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.DatabaseIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an InboxMessageIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for InboxMessageIdentifier.",
      "scenario": "Given a test table and a generated InboxMessageIdentifier value.",
      "behavior": "Then the retrieved InboxMessageIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 187,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.InboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an InstanceIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for InstanceIdentifier.",
      "scenario": "Given a test table and a generated InstanceIdentifier value.",
      "behavior": "Then the retrieved InstanceIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 363,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.InstanceIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a JoinIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for JoinIdentifier.",
      "scenario": "Given a test table and a generated JoinIdentifier value.",
      "behavior": "Then the retrieved JoinIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 319,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.JoinIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a nullable OwnerToken is stored and retrieved, then values round-trip and nulls remain null.",
      "intent": "Validate nullable OwnerToken handling in Dapper.",
      "scenario": "Given a test table and a nullable OwnerToken value inserted once with a value and once with null.",
      "behavior": "Then the first row returns the original OwnerToken and the second row returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.NullableOwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxMessageIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OutboxMessageIdentifier.",
      "scenario": "Given a test table and a generated OutboxMessageIdentifier value.",
      "behavior": "Then the retrieved OutboxMessageIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 231,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.OutboxMessageIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an OutboxWorkItemIdentifier is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OutboxWorkItemIdentifier.",
      "scenario": "Given a test table and a generated OutboxWorkItemIdentifier value.",
      "behavior": "Then the retrieved OutboxWorkItemIdentifier equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 275,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.OutboxWorkItemIdentifier_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an OwnerToken is inserted and retrieved via Dapper, then it round-trips to the same value.",
      "intent": "Validate the Dapper type handler for OwnerToken.",
      "scenario": "Given a test table and a generated OwnerToken value.",
      "behavior": "Then the retrieved OwnerToken equals the original value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DapperTypeHandlerTests.cs",
        "line": 75,
        "member": "Bravellian.Platform.Tests.DapperTypeHandlerTests.OwnerToken_RoundTrip_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a custom schema name is used, then scheduler tables and indexes are created in that schema.",
      "intent": "Ensure schema customization works for scheduler artifacts.",
      "scenario": "Given DatabaseSchemaManager.EnsureSchedulerSchemaAsync called with a custom schema and table names.",
      "behavior": "Then the custom tables exist and the expected index name is present.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 291,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.CustomSchemaNames_WorkCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the schema is deployed, then all required core tables exist in the infra schema.",
      "intent": "Verify core platform tables are created in the test database.",
      "scenario": "Given schema deployment for outbox, inbox, scheduler, and fanout modules.",
      "behavior": "Then the expected table names are present under infra.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 58,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.DatabaseSchema_AllRequiredTablesExist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Inbox table, then required columns exist with expected data types.",
      "intent": "Ensure inbox schema matches production column definitions.",
      "scenario": "Given the Inbox table deployed in the infra schema.",
      "behavior": "Then all inbox columns are present with correct types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 235,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.InboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the JobRuns table, then required columns exist with expected data types.",
      "intent": "Ensure job run schema matches production column definitions.",
      "scenario": "Given the JobRuns table deployed in the infra schema.",
      "behavior": "Then all job run and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 198,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobRunsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Jobs table, then required columns exist with expected data types.",
      "intent": "Ensure jobs schema matches production column definitions.",
      "scenario": "Given the Jobs table deployed in the infra schema.",
      "behavior": "Then all job definition columns are present with correct types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 128,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.JobsTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Outbox table, then required columns exist with expected data types.",
      "intent": "Ensure outbox schema matches production column definitions.",
      "scenario": "Given the Outbox table deployed in the infra schema.",
      "behavior": "Then all essential outbox and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 88,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.OutboxTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.RequiredIndexes_ExistOnAllTables",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When required indexes are inspected, then core tables have the expected indexes.",
      "intent": "Verify production index definitions are present in tests.",
      "scenario": "Given the infra schema with deployed tables and indexes.",
      "behavior": "Then the outbox, jobs, timers, and job runs indexes exist.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 266,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.RequiredIndexes_ExistOnAllTables"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When inspecting the Timers table, then required columns exist with expected data types.",
      "intent": "Ensure timers schema matches production column definitions.",
      "scenario": "Given the Timers table deployed in the infra schema.",
      "behavior": "Then all timer and work-queue columns are present with correct types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.TimersTable_HasCorrectSchema"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When work-queue migrations are applied, then work-queue columns and types exist.",
      "intent": "Verify work-queue migration adds required columns and table types.",
      "scenario": "Given the Outbox table after schema deployment.",
      "behavior": "Then Status, LockedUntil, OwnerToken, and the GuidIdList type exist.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 333,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueColumns_ExistAfterMigration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueProcedures_UseDatabaseUtcTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When work-queue procedures are inspected, then they use SYSUTCDATETIME for timing.",
      "intent": "Ensure stored procedures rely on database-authoritative time.",
      "scenario": "Given the Outbox and Inbox work-queue procedures deployed in infra.",
      "behavior": "Then procedure definitions include SYSUTCDATETIME.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaConsistencyTests.cs",
        "line": 358,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaConsistencyTests.WorkQueueProcedures_UseDatabaseUtcTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithControlPlane_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When control-plane registration enables schema deployment, then schema services are registered.",
      "intent": "Ensure schema deployment services are added for control-plane registration.",
      "scenario": "Given AddPlatformMultiDatabaseWithControlPlaneAndList with EnableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithControlPlane_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multi-database list registration disables schema deployment, then schema services are not registered.",
      "intent": "Avoid schema deployment services when list-based registration disables deployment.",
      "scenario": "Given AddPlatformMultiDatabaseWithList with enableSchemaDeployment set to false.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 269,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multi-database list registration enables schema deployment, then schema services are registered.",
      "intent": "Ensure schema deployment services are added for list-based registration.",
      "scenario": "Given AddPlatformMultiDatabaseWithList with enableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 182,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddPlatformMultiDatabaseWithList_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox disables schema deployment, then schema completion and background services are not registered.",
      "intent": "Avoid schema deployment services when deployment is disabled.",
      "scenario": "Given SqlOutboxOptions with EnableSchemaDeployment set to false.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are absent from the service collection.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 72,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentDisabled_DoesNotRegisterSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox enables schema deployment, then schema completion and background services are registered.",
      "intent": "Ensure schema deployment wiring is added when enabled.",
      "scenario": "Given SqlOutboxOptions with EnableSchemaDeployment set to true.",
      "behavior": "Then IDatabaseSchemaCompletion and DatabaseSchemaBackgroundService are registered in the service collection.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 38,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.AddSqlOutbox_WithSchemaDeploymentEnabled_RegistersSchemaService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When DatabaseSchemaCompletion is completed, then its completion task transitions to RanToCompletion.",
      "intent": "Ensure schema completion state tracking works as expected.",
      "scenario": "Given a new DatabaseSchemaCompletion instance.",
      "behavior": "Then SchemaDeploymentCompleted is initially incomplete and becomes completed after SetCompleted.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 153,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.DatabaseSchemaCompletion_CoordinatesStateCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When schema deployment is enabled, then IDatabaseSchemaCompletion and DatabaseSchemaCompletion are registered separately.",
      "intent": "Verify schema completion registrations use the expected lifetimes and factories.",
      "scenario": "Given AddSqlOutbox with schema deployment enabled.",
      "behavior": "Then IDatabaseSchemaCompletion is a singleton factory and DatabaseSchemaCompletion is registered directly.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 106,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaCompletion_RegisteredSeparatelyFromBackgroundService"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaSnapshotManifest_IsTracked",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the schema snapshot manifest is expected, then the snapshot file exists on disk.",
      "intent": "Ensure the schema snapshot artifact is tracked in the repository.",
      "scenario": "Given the expected schema snapshot file path from SchemaVersionSnapshot.",
      "behavior": "Then the snapshot file exists at the expected location.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DatabaseSchemaDeploymentTests.cs",
        "line": 309,
        "member": "Bravellian.Platform.Tests.DatabaseSchemaDeploymentTests.SchemaSnapshotManifest_IsTracked"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MixedBehavior",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When processed counts vary across calls, then SelectNext sticks to busy stores and advances when empty.",
      "intent": "Validate mixed drain-first behavior across multiple stores.",
      "scenario": "Given three mock stores with alternating non-zero and zero processed counts.",
      "behavior": "Then SelectNext stays on active stores and moves on when processed count is zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 110,
        "member": "Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MixedBehavior"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MovesToNextStoreWhenNoMessagesProcessed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no messages are processed, then SelectNext advances to the next store.",
      "intent": "Verify drain-first advances when a store has no work.",
      "scenario": "Given three mock stores and zero processed counts on each call.",
      "behavior": "Then SelectNext moves to the next store and wraps around.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 83,
        "member": "Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_MovesToNextStoreWhenNoMessagesProcessed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_SticksToSameStoreWhenMessagesProcessed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a store processes messages, then SelectNext keeps returning the same store.",
      "intent": "Ensure drain-first strategy sticks to the current store while work is processed.",
      "scenario": "Given three mock stores and non-zero processed counts for the current store.",
      "behavior": "Then SelectNext continues to return the first store.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_SticksToSameStoreWhenMessagesProcessed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called with no stores, then it returns null.",
      "intent": "Verify drain-first selection handles empty inputs safely.",
      "scenario": "Given an empty store list and a new DrainFirstOutboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DrainFirstSelectionStrategyTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.DrainFirstSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformProviders_ShouldUseDiscoveryAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Verifies that providers use the correct discovery instance.",
      "intent": "Ensure providers use IPlatformDatabaseDiscovery results for tenant enumeration.",
      "scenario": "Given discovery returns two tenant databases and AddPlatformMultiDatabaseWithDiscovery is used.",
      "behavior": "Then outbox, inbox, scheduler, lease, and fanout providers each return two entries.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 205,
        "member": "Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformProviders_ShouldUseDiscoveryAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldNotConfigureCustomerDatabaseOptions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldNotConfigureCustomerDatabaseOptions"
      },
      "status": "missing-required",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldRegisterAllProviders",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "Verifies that all customer database features have their providers registered when using platform registration.",
      "intent": "Validate provider registration for outbox, inbox, scheduler, fanout, and leases.",
      "scenario": "Given AddPlatformMultiDatabaseWithDiscovery and a discovery implementation.",
      "behavior": "Then the outbox, inbox, scheduler, fanout, and lease providers resolve from the service provider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 155,
        "member": "Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithDiscovery_ShouldRegisterAllProviders"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithList_ShouldNotConfigureCustomerDatabaseOptions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicDiscoveryEnforcementTests.cs",
        "line": 102,
        "member": "Bravellian.Platform.Tests.DynamicDiscoveryEnforcementTests.PlatformWithList_ShouldNotConfigureCustomerDatabaseOptions"
      },
      "status": "missing-required",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new inbox database is added to discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added inbox databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 104,
        "member": "Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an inbox database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed inbox databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic inbox provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates inbox work stores from discovery results.",
      "scenario": "Given a SampleInboxDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 51,
        "member": "Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior for inbox work stores.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllStoresAsync to return two stores.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicInboxWorkStoreProviderTests.cs",
        "line": 216,
        "member": "Bravellian.Platform.Tests.DynamicInboxWorkStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsConnectionStringChanges",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a connection string changes for an existing key, then RefreshAsync recreates the factory.",
      "intent": "Ensure the provider detects connection string changes and refreshes factories.",
      "scenario": "Given Customer1 is removed and re-added with a new connection string before RefreshAsync.",
      "behavior": "Then the factory for Customer1 is replaced with a new instance.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 333,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsConnectionStringChanges"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new lease database is added to discovery, then RefreshAsync updates the factory list.",
      "intent": "Ensure the provider detects newly added lease databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers for both customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 104,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease database is removed from discovery, then RefreshAsync removes its factory.",
      "intent": "Ensure the provider drops factories for removed lease databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllFactoriesAsync returns one factory identified as Customer1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 161,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic lease provider performs initial discovery, then it returns factories for all configured databases.",
      "intent": "Verify initial discovery populates lease factories from discovery results.",
      "scenario": "Given a SampleLeaseDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllFactoriesAsync returns two factories with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 51,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_GetFactoryByKey_ReturnsCorrectFactory",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When known lease keys are requested, then GetFactoryByKeyAsync returns the matching factories.",
      "intent": "Verify keyed lease factory lookup works after discovery.",
      "scenario": "Given discovery provides Customer1 and Customer2 and initial discovery has completed.",
      "behavior": "Then known keys return factories and an unknown key returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 273,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_GetFactoryByKey_ReturnsCorrectFactory"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior for lease factories.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllFactoriesAsync to return two factories.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicLeaseFactoryProviderTests.cs",
        "line": 218,
        "member": "Bravellian.Platform.Tests.DynamicLeaseFactoryProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new outbox database is added to discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added outbox databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an outbox database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed outbox databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 183,
        "member": "Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic outbox provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates outbox stores from discovery results.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 74,
        "member": "Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the refresh interval elapses, then the provider automatically refreshes discovery results.",
      "intent": "Validate time-based automatic refresh behavior.",
      "scenario": "Given a FakeTimeProvider, one initial database, and a second database added before time advances.",
      "behavior": "Then advancing time past the interval causes GetAllStoresAsync to return two stores.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicOutboxStoreProviderTests.cs",
        "line": 239,
        "member": "Bravellian.Platform.Tests.DynamicOutboxStoreProviderTests.DynamicProvider_RefreshesAutomaticallyAfterInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsNewDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new database appears in discovery, then RefreshAsync updates the store list.",
      "intent": "Ensure the provider detects newly added scheduler databases.",
      "scenario": "Given discovery initially returns Customer1 and later adds Customer2 before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers for both customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 131,
        "member": "Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsNewDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsRemovedDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a database is removed from discovery, then RefreshAsync removes its store.",
      "intent": "Ensure the provider drops stores for removed scheduler databases.",
      "scenario": "Given discovery initially returns Customer1 and Customer2, then Customer2 is removed before RefreshAsync.",
      "behavior": "Then GetAllStoresAsync returns one store identified as Customer1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 186,
        "member": "Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DetectsRemovedDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DiscoversInitialDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dynamic scheduler provider performs initial discovery, then it returns stores for all configured databases.",
      "intent": "Verify initial discovery populates scheduler stores from discovery results.",
      "scenario": "Given a SampleSchedulerDatabaseDiscovery returning Customer1 and Customer2 configs.",
      "behavior": "Then GetAllStoresAsync returns two stores with identifiers matching the discovered customers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 74,
        "member": "Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_DiscoversInitialDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsCorrectClient",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a known scheduler key is requested, then GetSchedulerClientByKey returns a client instance.",
      "intent": "Verify keyed scheduler client lookup works after discovery.",
      "scenario": "Given discovery provides Customer1 and initial discovery has completed.",
      "behavior": "Then GetSchedulerClientByKey(\u0022Customer1\u0022) returns a non-null client.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 241,
        "member": "Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsCorrectClient"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsNullForUnknownKey",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an unknown scheduler key is requested, then GetSchedulerClientByKey returns null.",
      "intent": "Ensure missing scheduler keys are reported as null lookups.",
      "scenario": "Given discovery provides Customer1 and initial discovery has completed.",
      "behavior": "Then GetSchedulerClientByKey(\u0022UnknownCustomer\u0022) returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/DynamicSchedulerStoreProviderTests.cs",
        "line": 285,
        "member": "Bravellian.Platform.Tests.DynamicSchedulerStoreProviderTests.DynamicProvider_GetSchedulerClientByKey_ReturnsNullForUnknownKey"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Discovery_service_filters_engines",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When engines are listed and resolved with filters, then discovery returns the expected UI and webhook descriptors.",
      "intent": "Validate engine discovery filtering and webhook resolution by provider and event.",
      "scenario": "Given a ModuleEngineDiscoveryService built from FakeEngineModule descriptors.",
      "behavior": "Then UI and webhook engines are found via filters and ResolveWebhookEngine returns the expected module key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 307,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Discovery_service_filters_engines"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_contract_is_mismatched",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a UI adapter targets an engine with a non-UI contract, then ExecuteAsync throws.",
      "intent": "Prevent UI adapters from invoking engines with mismatched contracts.",
      "scenario": "Given a UiEngineAdapter and a request for a webhook engine ID.",
      "behavior": "Then ExecuteAsync throws InvalidOperationException indicating the UI contract mismatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 283,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_contract_is_mismatched"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_is_not_registered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a UI engine is not registered for the requested engine ID, then ExecuteAsync throws.",
      "intent": "Ensure missing UI engines surface a clear error.",
      "scenario": "Given a UiEngineAdapter and a request targeting an unknown UI engine ID.",
      "behavior": "Then ExecuteAsync throws InvalidOperationException with a \u0022No UI engine registered\u0022 message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 259,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Ui_adapter_throws_when_engine_is_not_registered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Ui_engine_exception_propagates_to_adapter",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the UI engine throws during execution, then the adapter propagates the exception.",
      "intent": "Ensure engine exceptions are not swallowed by the adapter.",
      "scenario": "Given a LoginCommand with a missing username that triggers an ArgumentException in the engine.",
      "behavior": "Then ExecuteAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 237,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Ui_engine_exception_propagates_to_adapter"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Ui_engine_invocation_returns_view_model_and_navigation_tokens",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the UI engine executes a valid login command, then it returns a view model and navigation tokens.",
      "intent": "Verify UI engine execution returns expected view model data and navigation metadata.",
      "scenario": "Given a UiEngineAdapter wired with FakeEngineModule and a LoginCommand with credentials.",
      "behavior": "Then the response contains the username, a dashboard navigation token, and a login event.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 45,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Ui_engine_invocation_returns_view_model_and_navigation_tokens"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_enforces_signature_and_maps_outcome",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a webhook request has a valid signature, then the adapter dispatches and returns an enqueue outcome.",
      "intent": "Ensure signature validation gates webhook dispatch and outcome mapping.",
      "scenario": "Given a WebhookEngineAdapter using TestSignatureValidator and a request with a valid signature header.",
      "behavior": "Then DispatchAsync returns a response with Outcome set to EnqueueEvent.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 70,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_enforces_signature_and_maps_outcome"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_rejects_invalid_signature",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a webhook request has an invalid signature, then the adapter acknowledges it with a failure reason.",
      "intent": "Verify invalid signatures are rejected without dispatching the engine.",
      "scenario": "Given a WebhookEngineAdapter and a request with an invalid signature header.",
      "behavior": "Then DispatchAsync returns Outcome Acknowledge and a reason mentioning signature validation.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 103,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_rejects_invalid_signature"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_requires_idempotency_key_when_configured",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a webhook request omits a required idempotency key, then the adapter responds with a retry.",
      "intent": "Enforce idempotency requirements on webhook dispatch.",
      "scenario": "Given a WebhookEngineAdapter and a request with an empty or whitespace idempotency key.",
      "behavior": "Then DispatchAsync returns Outcome Retry with a reason stating the key is required.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 139,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_requires_idempotency_key_when_configured"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_throws_when_engine_contract_is_mismatched",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the webhook payload type does not match the engine contract, then DispatchAsync throws.",
      "intent": "Guard against mismatched webhook payload contracts.",
      "scenario": "Given a WebhookEngineAdapter and a request with an incompatible payload type.",
      "behavior": "Then DispatchAsync throws InvalidOperationException indicating the contract mismatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 205,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_throws_when_engine_contract_is_mismatched"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_throws_when_engine_is_not_registered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a webhook engine is not registered for the provider/event, then DispatchAsync throws.",
      "intent": "Ensure missing webhook engines are reported as errors.",
      "scenario": "Given a WebhookEngineAdapter and a request for a missing provider/event pair.",
      "behavior": "Then DispatchAsync throws InvalidOperationException with a \u0022No webhook engine registered\u0022 message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/EngineRefactoringTests.cs",
        "line": 173,
        "member": "Bravellian.Platform.Tests.EngineRefactoringTests.Webhook_adapter_throws_when_engine_is_not_registered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.ExceptionFilter_InRealCatchBlock_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is used in a real catch filter, then it catches the regular exception.",
      "intent": "Demonstrate catch-filter usage with the exception filter.",
      "scenario": "Given a thrown InvalidOperationException inside a try/catch with ExceptionFilter.IsCatchable.",
      "behavior": "Then the exception is caught and recorded in the list.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 523,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.ExceptionFilter_InRealCatchBlock_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.ExceptionFilter_WithCriticalException_DoesNotCatch",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a critical exception is thrown, then the catch filter does not intercept it.",
      "intent": "Ensure critical exceptions bypass catchable filters.",
      "scenario": "Given an OutOfMemoryException thrown inside a try/catch with ExceptionFilter.IsCatchable.",
      "behavior": "Then the filter does not catch the exception and the flag remains false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 555,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.ExceptionFilter_WithCriticalException_DoesNotCatch"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_RealWorldScenario_SqlExceptions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When evaluating a catchable SQL-like exception versus a critical one, then only the catchable exception returns true.",
      "intent": "Demonstrate real-world filtering that excludes critical exceptions.",
      "scenario": "Given an InvalidOperationException representing a SQL error and an OutOfMemoryException representing a critical error.",
      "behavior": "Then IsCatchableAndExpected returns true for the SQL-like exception and false for the critical exception.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 650,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_RealWorldScenario_SqlExceptions"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableAndExpected_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an exception is both catchable and expected, then IsCatchableAndExpected returns true.",
      "intent": "Validate combined catchable and expected filtering logic.",
      "scenario": "Given an InvalidOperationException and expected type InvalidOperationException.",
      "behavior": "Then IsCatchableAndExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 423,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableAndExpected_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableButNotExpected_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an exception is catchable but not expected, then IsCatchableAndExpected returns false.",
      "intent": "Ensure expected-type filtering is enforced even for catchable exceptions.",
      "scenario": "Given an InvalidOperationException and an expected type of ArgumentException.",
      "behavior": "Then IsCatchableAndExpected returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 477,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCatchableButNotExpected_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCriticalButExpected_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an exception is critical even if expected, then IsCatchableAndExpected returns false.",
      "intent": "Ensure critical exceptions are never treated as catchable.",
      "scenario": "Given an OutOfMemoryException and expected type OutOfMemoryException.",
      "behavior": "Then IsCatchableAndExpected returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 450,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithCriticalButExpected_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithNullException_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchableAndExpected is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for combined filtering.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 504,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchableAndExpected_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithNullException_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \u0022exception\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 107,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithOutOfMemoryException_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given an OutOfMemoryException, then it returns false.",
      "intent": "Ensure critical exceptions are not marked catchable.",
      "scenario": "Given an OutOfMemoryException instance.",
      "behavior": "Then IsCatchable returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 57,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithOutOfMemoryException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithRegularException_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given a regular exception, then it returns true.",
      "intent": "Verify non-critical exceptions are considered catchable.",
      "scenario": "Given an InvalidOperationException instance.",
      "behavior": "Then IsCatchable returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 32,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithRegularException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithStackOverflowException_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is given a StackOverflowException, then it returns false.",
      "intent": "Ensure stack overflow is treated as non-catchable.",
      "scenario": "Given a StackOverflowException instance.",
      "behavior": "Then IsCatchable returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 82,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithStackOverflowException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithVariousCommonExceptions_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCatchable is evaluated for common exception types, then it returns true.",
      "intent": "Validate catchable classification for typical application exceptions.",
      "scenario": "Given an exception instance created from each common exception type in the data set.",
      "behavior": "Then IsCatchable returns true for each provided type.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 600,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCatchable_WithVariousCommonExceptions_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithNullException_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for critical checks.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \u0022exception\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 202,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithOutOfMemoryException_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given an OutOfMemoryException, then it returns true.",
      "intent": "Classify out-of-memory conditions as critical.",
      "scenario": "Given an OutOfMemoryException instance.",
      "behavior": "Then IsCritical returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithOutOfMemoryException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithRegularException_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given a regular exception, then it returns false.",
      "intent": "Ensure non-critical exceptions are not flagged as critical.",
      "scenario": "Given an ArgumentException instance.",
      "behavior": "Then IsCritical returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 177,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithRegularException_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithStackOverflowException_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsCritical is given a StackOverflowException, then it returns true.",
      "intent": "Classify stack overflow conditions as critical.",
      "scenario": "Given a StackOverflowException instance.",
      "behavior": "Then IsCritical returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 152,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsCritical_WithStackOverflowException_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithDerivedType_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a derived exception and a base expected type, then it returns true.",
      "intent": "Confirm base expected types match derived exceptions.",
      "scenario": "Given an ArgumentNullException and expected type ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 276,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithDerivedType_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithEmptyExpectedTypes_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with no expected types, then it returns false.",
      "intent": "Ensure empty expected type lists do not match any exception.",
      "scenario": "Given an InvalidOperationException and an empty expected type list.",
      "behavior": "Then IsExpected returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 369,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithEmptyExpectedTypes_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithMatchingType_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a matching exception type, then it returns true.",
      "intent": "Confirm exact type matches are treated as expected.",
      "scenario": "Given an InvalidOperationException and an expected type of InvalidOperationException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithMatchingType_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithMultipleTypesAndMatch_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given multiple expected types including a base type, then it returns true for a derived exception.",
      "intent": "Validate derived exceptions match any compatible expected type.",
      "scenario": "Given an ArgumentNullException and expected types that include ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 247,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithMultipleTypesAndMatch_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNonMatchingType_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given a non-matching expected type, then it returns false.",
      "intent": "Ensure unrelated exception types are not marked expected.",
      "scenario": "Given an InvalidOperationException and expected type ArgumentException.",
      "behavior": "Then IsExpected returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 301,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNonMatchingType_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullException_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with a null exception, then it throws ArgumentNullException.",
      "intent": "Guard against null exception inputs for expected checks.",
      "scenario": "Given a null exception argument.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \u0022exception\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 326,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullException_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullExpectedTypes_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is called with null expected types, then it throws ArgumentNullException.",
      "intent": "Guard against null expected type arrays.",
      "scenario": "Given a non-null exception and a null expectedTypes array.",
      "behavior": "Then an ArgumentNullException is thrown with parameter name \u0022expectedTypes\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 346,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullExpectedTypes_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullTypeInArray_IgnoresNullAndContinues",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected encounters null entries in expected types, then it ignores them and still matches valid types.",
      "intent": "Verify null expected types do not break matching.",
      "scenario": "Given an ArgumentException and expected types containing nulls and ArgumentException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 394,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithNullTypeInArray_IgnoresNullAndContinues"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithOperationCanceledException_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IsExpected is given an OperationCanceledException and matching expected type, then it returns true.",
      "intent": "Confirm cancellation exceptions are matched when expected.",
      "scenario": "Given an OperationCanceledException and expected type OperationCanceledException.",
      "behavior": "Then IsExpected returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ExceptionFilterTests.cs",
        "line": 625,
        "member": "Bravellian.Platform.Tests.ExceptionFilterTests.IsExpected_WithOperationCanceledException_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When fanout slices share a correlation ID, then join completion is idempotent and correlation IDs match.",
      "intent": "Validate downstream join tracking for fanout-dispatched messages.",
      "scenario": "Given three slices dispatched with the same correlation ID and a join expecting three steps.",
      "behavior": "Then completed steps remain at three after replay and all outbox messages share one correlation ID.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 201,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.FanoutSlices_CanJoinDownstreamMessagesIdempotently"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cursors do not advance, then RunAsync redispatches the same slice on subsequent runs.",
      "intent": "Ensure abandoned slices can be redispatched.",
      "scenario": "Given a static planner with one slice and an in-memory lease factory.",
      "behavior": "Then two consecutive runs each dispatch one message and outbox payloads match the slice shard.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 130,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RedispatchesAbandonedSlices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is active, then RunAsync returns no dispatches, and after the lease expires it dispatches the slice once.",
      "intent": "Verify lease gating and recovery behavior for the fanout coordinator.",
      "scenario": "Given an active in-memory lease for the fanout topic and a planner with a single slice.",
      "behavior": "Then the first RunAsync returns zero and the later RunAsync dispatches one message into the outbox.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 93,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_RespectsActiveLeaseAndRecoversAfterExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When fanout cursors are marked completed, then RunAsync skips dispatching completed slices.",
      "intent": "Confirm cursor advancement prevents duplicate dispatches.",
      "scenario": "Given a sharded planner that dispatches two shards and cursors marked completed for both shards.",
      "behavior": "Then a subsequent RunAsync returns zero dispatched slices.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutCoordinatorIntegrationTests.cs",
        "line": 164,
        "member": "Bravellian.Platform.Tests.FanoutCoordinatorIntegrationTests.RunAsync_SkipsCompletedSlicesAfterCursorAdvances"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddDynamicMultiSqlFanout_RegistersServicesCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic fanout discovery loads tenants, then policy and cursor repositories are created for each tenant.",
      "intent": "Validate discovery-based fanout configuration builds repositories from discovered databases.",
      "scenario": "Given a MockFanoutDatabaseDiscovery returning two tenants and a DynamicFanoutRepositoryProvider.",
      "behavior": "Then repository lists contain two policy repositories and two cursor repositories.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutRouterIntegrationTests.cs",
        "line": 251,
        "member": "Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddDynamicMultiSqlFanout_RegistersServicesCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_RepositoryProvider_ReturnsCorrectIdentifiers",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When repository identifiers are requested, then each repository returns a unique non-empty identifier.",
      "intent": "Ensure repository identifiers map uniquely to configured tenants.",
      "scenario": "Given a ConfiguredFanoutRepositoryProvider created from two SqlFanoutOptions entries.",
      "behavior": "Then the repository identifiers are populated and distinct.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutRouterIntegrationTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_RepositoryProvider_ReturnsCorrectIdentifiers"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_WithListOfOptions_RegistersServicesCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When fanout is configured with multiple option entries, then repositories are created per tenant and routed correctly.",
      "intent": "Validate list-based fanout configuration builds distinct policy and cursor repositories.",
      "scenario": "Given two SqlFanoutOptions entries and a ConfiguredFanoutRepositoryProvider.",
      "behavior": "Then repository counts match the option entries and router returns distinct repositories per tenant.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutRouterIntegrationTests.cs",
        "line": 50,
        "member": "Bravellian.Platform.Tests.FanoutRouterIntegrationTests.AddMultiSqlFanout_WithListOfOptions_RegistersServicesCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ReturnsCorrectRepository",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a known tenant key is requested, then FanoutRouter returns the policy and cursor repositories.",
      "intent": "Verify router lookup returns repositories for configured tenants.",
      "scenario": "Given a single SqlFanoutOptions entry for Tenant1 and a FanoutRouter built from it.",
      "behavior": "Then GetPolicyRepository and GetCursorRepository return non-null repositories.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutRouterIntegrationTests.cs",
        "line": 172,
        "member": "Bravellian.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ReturnsCorrectRepository"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ThrowsWhenKeyNotFound",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a tenant key is missing, then FanoutRouter throws an InvalidOperationException containing the key.",
      "intent": "Ensure invalid fanout keys are rejected with actionable errors.",
      "scenario": "Given a FanoutRouter configured for Tenant1 only and a lookup for \u0022NonExistentKey\u0022.",
      "behavior": "Then both policy and cursor repository lookups throw and mention the missing key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutRouterIntegrationTests.cs",
        "line": 211,
        "member": "Bravellian.Platform.Tests.FanoutRouterIntegrationTests.FanoutRouter_GetPolicyRepository_ThrowsWhenKeyNotFound"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutSystemTests.FanoutDispatcher_ShouldCreateCorrectTopicName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a fanout topic name is constructed, then it follows the \u0022fanout:{fanoutTopic}:{workKey}\u0022 convention.",
      "intent": "Document the fanout topic naming pattern used by the dispatcher.",
      "scenario": "Given a fanout topic of \u0022etl\u0022 and a work key of \u0022payments\u0022.",
      "behavior": "Then the expected topic is \u0022fanout:etl:payments\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutSystemTests.cs",
        "line": 71,
        "member": "Bravellian.Platform.Tests.FanoutSystemTests.FanoutDispatcher_ShouldCreateCorrectTopicName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutSystemTests.FanoutSlice_ShouldSerializeCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a FanoutSlice is serialized and deserialized, then its fields are preserved.",
      "intent": "Ensure FanoutSlice JSON round-trips correctly.",
      "scenario": "Given a FanoutSlice with explicit topic, shard key, work key, window start, and correlation ID.",
      "behavior": "Then the deserialized slice matches the original field values.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutSystemTests.cs",
        "line": 35,
        "member": "Bravellian.Platform.Tests.FanoutSystemTests.FanoutSlice_ShouldSerializeCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.FanoutSystemTests.FanoutTopicOptions_ShouldHaveCorrectDefaults",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FanoutTopicOptions is created with a fanout topic, then its default scheduling values are set.",
      "intent": "Verify default values for fanout scheduling configuration.",
      "scenario": "Given a FanoutTopicOptions instance with FanoutTopic set and no other overrides.",
      "behavior": "Then work key is null and cron, interval, jitter, and lease defaults are populated.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/FanoutSystemTests.cs",
        "line": 94,
        "member": "Bravellian.Platform.Tests.FanoutSystemTests.FanoutTopicOptions_ShouldHaveCorrectDefaults"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the cleanup stored procedure is missing, then the cleanup service runs without crashing.",
      "intent": "Ensure the background cleanup service tolerates missing schema deployment.",
      "scenario": "Given an inbox database with the cleanup procedure dropped and a short cleanup interval.",
      "behavior": "Then StartAsync completes without throwing and the procedure remains missing.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxCleanupTests.cs",
        "line": 221,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a retention window, then only processed messages older than the window are deleted.",
      "intent": "Verify the cleanup procedure removes stale processed inbox records.",
      "scenario": "Given old processed, recent processed, and unprocessed inbox rows before running cleanup.",
      "behavior": "Then only the old processed message is deleted and other rows remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxCleanupTests.cs",
        "line": 45,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a 10-day retention period, then only messages older than 10 days are deleted.",
      "intent": "Confirm retention period filtering is applied correctly.",
      "scenario": "Given processed messages at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Then the 30- and 15-day messages are deleted while newer messages remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxCleanupTests.cs",
        "line": 163,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs and no processed messages are older than retention, then nothing is deleted.",
      "intent": "Ensure cleanup is a no-op when no rows qualify.",
      "scenario": "Given only a recent processed inbox message before running cleanup.",
      "behavior": "Then the cleanup procedure deletes zero rows and the message remains.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxCleanupTests.cs",
        "line": 122,
        "member": "Bravellian.Platform.Tests.InboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync is called multiple times, then each run uses a new owner token.",
      "intent": "Ensure dispatcher rotates owner tokens across separate runs.",
      "scenario": "Given a StubInboxWorkStore and two RunOnceAsync calls.",
      "behavior": "Then the store captures two distinct owner tokens.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 229,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_RotatesOwnerTokensAcrossRuns"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails and a backoff policy is supplied, then the message is abandoned with that delay.",
      "intent": "Ensure dispatcher honors custom backoff delays on failure.",
      "scenario": "Given a StubInboxWorkStore, a failing handler, and a backoff policy returning 5 seconds.",
      "behavior": "Then the message is abandoned with the configured delay and not failed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 165,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_AbandonsWithBackoffPolicy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then RunOnceAsync abandons the message for retry.",
      "intent": "Validate failure paths return messages to Seen for future retries.",
      "scenario": "Given an enqueued message handled by a FailingInboxHandler that throws.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Seen.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 131,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithFailingHandler_RetriesWithBackoff"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then RunOnceAsync marks the message Dead.",
      "intent": "Ensure unhandled topics are failed instead of retried indefinitely.",
      "scenario": "Given an enqueued inbox message with an unknown topic and no registered handlers.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Dead.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 98,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoHandlerForTopic_MarksMessageAsDead"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When RunOnceAsync is called with no inbox messages, then it returns zero processed items.",
      "intent": "Verify the dispatcher reports no work when the store is empty.",
      "scenario": "Given a SqlInboxWorkStore with no queued messages and an empty handler resolver.",
      "behavior": "Then RunOnceAsync returns 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithNoMessages_ReturnsZero"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message exceeds max attempts, then RunOnceAsync fails it instead of retrying.",
      "intent": "Verify poison-message handling respects maxAttempts.",
      "scenario": "Given a StubInboxWorkStore message with attempt count at maxAttempts.",
      "behavior": "Then the message is marked failed and not abandoned.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 197,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithPoisonMessage_FailsInsteadOfRetrying"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message has a matching handler, then RunOnceAsync processes it and marks it Done.",
      "intent": "Validate successful handler execution updates inbox status.",
      "scenario": "Given an enqueued inbox message and a TestInboxHandler registered for its topic.",
      "behavior": "Then RunOnceAsync returns 1 and the message status is Done.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxDispatcherTests.cs",
        "line": 65,
        "member": "Bravellian.Platform.Tests.InboxDispatcherTests.RunOnceAsync_WithValidMessage_ProcessesSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the inbox service is used end-to-end, then a message transitions to Done and is reported as processed.",
      "intent": "Validate the core inbox workflow from first check through completion.",
      "scenario": "Given a SqlInboxService created with options and a test logger.",
      "behavior": "Then the first AlreadyProcessedAsync returns false, the second returns true, and the DB status is Done.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxIntegrationTests.cs",
        "line": 39,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.CompleteInboxWorkflow_DirectServiceUsage_WorksEndToEnd"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple threads call AlreadyProcessedAsync concurrently, then only one record is created and attempts are tracked.",
      "intent": "Ensure inbox deduplication remains safe under concurrent access.",
      "scenario": "Given ten concurrent SqlInboxService instances calling AlreadyProcessedAsync for the same message id.",
      "behavior": "Then all calls return false, one record exists, and Attempts equals the task count.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxIntegrationTests.cs",
        "line": 113,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.ConcurrentAccess_WithMultipleThreads_HandledSafely"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is marked dead, then its inbox status is Dead and processed time remains null.",
      "intent": "Verify poison-message handling sets the expected state.",
      "scenario": "Given a SqlInboxService that marks a message as processing and then dead.",
      "behavior": "Then the database row status is Dead and ProcessedUtc is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxIntegrationTests.cs",
        "line": 79,
        "member": "Bravellian.Platform.Tests.InboxIntegrationTests.PoisonMessageWorkflow_MarkingAsDead_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_CreatesProviderCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is used, then a dynamic inbox provider and router can be created.",
      "intent": "Confirm the dynamic provider pattern constructs functional components.",
      "scenario": "Given a SampleInboxDatabaseDiscovery and a FakeTimeProvider with test logging.",
      "behavior": "Then a DynamicInboxWorkStoreProvider and InboxRouter are constructed successfully.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 164,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_CreatesProviderCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_WithCustomRefreshInterval_ConfiguresCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a custom refresh interval is supplied, then the dynamic provider is created with that setting.",
      "intent": "Ensure dynamic inbox discovery supports custom refresh intervals.",
      "scenario": "Given a SampleInboxDatabaseDiscovery and a custom refresh interval value.",
      "behavior": "Then a DynamicInboxWorkStoreProvider is constructed successfully using that interval.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 193,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddDynamicMultiSqlInbox_WithCustomRefreshInterval_ConfiguresCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithCustomSelectionStrategy_UsesProvidedStrategy",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a custom selection strategy is supplied, then a dispatcher can be built with it.",
      "intent": "Ensure the multi-inbox pattern supports replacing the selection strategy.",
      "scenario": "Given a DrainFirstInboxSelectionStrategy and a configured inbox provider.",
      "behavior": "Then a MultiInboxDispatcher is constructed successfully with the custom strategy.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 94,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithCustomSelectionStrategy_UsesProvidedStrategy"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithListOfOptions_RegistersServicesCorrectlyAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a list of inbox options is used, then the provider and router resolve inboxes for each tenant.",
      "intent": "Validate configured multi-inbox wiring produces usable stores and router outputs.",
      "scenario": "Given two SqlInboxOptions and a ConfiguredInboxWorkStoreProvider with a test logger.",
      "behavior": "Then GetAllStoresAsync returns two stores and the router returns distinct inboxes.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithListOfOptions_RegistersServicesCorrectlyAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithStoreProviderFactory_CreatesProviderCorrectlyAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the provider factory pattern is used, then a configured inbox store provider is created.",
      "intent": "Verify the factory produces a ConfiguredInboxWorkStoreProvider with expected stores.",
      "scenario": "Given a single SqlInboxOptions entry and a test logger factory.",
      "behavior": "Then GetAllStoresAsync returns one store from the configured provider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 131,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.AddMultiSqlInbox_WithStoreProviderFactory_CreatesProviderCorrectlyAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery loads tenant configurations, then routing returns distinct inboxes per tenant.",
      "intent": "Validate router behavior with dynamically discovered tenants.",
      "scenario": "Given a SampleInboxDatabaseDiscovery returning two tenant configs and an initial provider refresh.",
      "behavior": "Then GetInbox returns non-null, distinct inboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 264,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterIntegrationTests.MultiTenantScenario_RoutesToCorrectInbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When tenant keys are routed, then each key maps to a distinct inbox instance.",
      "intent": "Demonstrate multi-tenant routing using configured inbox options.",
      "scenario": "Given two SqlInboxOptions entries for Tenant1 and Tenant2.",
      "behavior": "Then the router returns two different inbox instances for each tenant.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterIntegrationTests.cs",
        "line": 221,
        "member": "Bravellian.Platform.Tests.InboxRouterIntegrationTests.MultiTenantScenario_RoutesToCorrectInbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithGuidKey_ReturnsInbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a Guid tenant key is requested, then the router returns an inbox instance.",
      "intent": "Verify inbox routing by Guid key converted to string.",
      "scenario": "Given a ConfiguredInboxWorkStoreProvider configured with a Guid-based connection string.",
      "behavior": "Then GetInbox(Guid) returns a non-null inbox.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterTests.cs",
        "line": 69,
        "member": "Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithGuidKey_ReturnsInbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithInvalidKey_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an unknown tenant key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure the router fails fast for missing tenant entries.",
      "scenario": "Given a provider with one configured tenant and a non-existent tenant key.",
      "behavior": "Then GetInbox throws InvalidOperationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterTests.cs",
        "line": 99,
        "member": "Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithInvalidKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithNullKey_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an empty tenant key is requested, then the router throws an ArgumentException.",
      "intent": "Validate tenant key input guarding.",
      "scenario": "Given a router configured with a single tenant and an empty key input.",
      "behavior": "Then GetInbox throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterTests.cs",
        "line": 125,
        "member": "Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithNullKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithNullProvider_ThrowsArgumentNullException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the router is constructed with a null provider, then it throws an ArgumentNullException.",
      "intent": "Ensure InboxRouter requires a non-null store provider.",
      "scenario": "Given an attempt to construct InboxRouter with a null IInboxWorkStoreProvider.",
      "behavior": "Then the constructor throws ArgumentNullException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterTests.cs",
        "line": 151,
        "member": "Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithNullProvider_ThrowsArgumentNullException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithValidKey_ReturnsInbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a configured tenant key is requested, then the router returns an inbox instance.",
      "intent": "Verify inbox routing by string key for configured stores.",
      "scenario": "Given a ConfiguredInboxWorkStoreProvider built from two SqlInboxOptions and a test logger.",
      "behavior": "Then GetInbox returns a non-null inbox for the matching tenant.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxRouterTests.cs",
        "line": 34,
        "member": "Bravellian.Platform.Tests.InboxRouterTests.InboxRouter_WithValidKey_ReturnsInbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_HandlesEmptyStoreList",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the drain-first strategy is given no stores, then it returns null.",
      "intent": "Ensure empty store lists are handled safely in drain-first selection.",
      "scenario": "Given an empty list of IInboxWorkStore and a DrainFirstInboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 158,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_HandlesEmptyStoreList"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_MovesToNextStoreWhenEmpty",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a store processes zero messages, then the drain-first strategy advances to the next store.",
      "intent": "Verify drain-first moves on when the current store is empty.",
      "scenario": "Given two MockInboxWorkStore instances and zero processed counts.",
      "behavior": "Then SelectNext advances to the next store and wraps when needed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_MovesToNextStoreWhenEmpty"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_ResetReturnsToFirstStore",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then drain-first selection starts from the first store again.",
      "intent": "Validate reset clears the drain-first cursor.",
      "scenario": "Given a strategy that has advanced to the second store.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 176,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_ResetReturnsToFirstStore"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_StaysOnStoreWithMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When messages are processed from a store, then the drain-first strategy stays on that store.",
      "intent": "Ensure drain-first keeps selecting the active store while work is processed.",
      "scenario": "Given two MockInboxWorkStore instances and non-zero processed counts.",
      "behavior": "Then SelectNext returns the current store repeatedly.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 101,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.DrainFirst_StaysOnStoreWithMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_CyclesThroughStoresEvenly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called repeatedly, then the round-robin strategy cycles through stores and wraps.",
      "intent": "Verify round-robin selection advances in order across inbox stores.",
      "scenario": "Given three MockInboxWorkStore instances and successive SelectNext calls.",
      "behavior": "Then the strategy returns store1, store2, store3, then wraps to store1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 27,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_CyclesThroughStoresEvenly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_HandlesEmptyStoreList",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the round-robin strategy is given no stores, then it returns null.",
      "intent": "Ensure empty store lists are handled safely.",
      "scenario": "Given an empty list of IInboxWorkStore and a RoundRobinInboxSelectionStrategy.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 57,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_HandlesEmptyStoreList"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_ResetReturnsToFirstStore",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then round-robin selection starts from the first store again.",
      "intent": "Validate reset clears the round-robin cursor.",
      "scenario": "Given a strategy that has already advanced to a later store.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxSelectionStrategyTests.cs",
        "line": 75,
        "member": "Bravellian.Platform.Tests.InboxSelectionStrategyTests.RoundRobin_ResetReturnsToFirstStore"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called by the owner, then the message returns to Seen status.",
      "intent": "Verify abandoning a claim resets the inbox state.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Seen and OwnerToken is cleared.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 161,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.AbandonAsync_WithClaimedMessage_ReturnsToSeen"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called by the owner, then the message is marked Done and processed time is set.",
      "intent": "Verify successful acknowledgements update inbox state.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Done, OwnerToken is cleared, and ProcessedUtc is set.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 128,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.AckAsync_WithClaimedMessage_MarksAsDone"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a ready message exists, then ClaimAsync claims it and marks it as processing.",
      "intent": "Verify claims update inbox status and owner token correctly.",
      "scenario": "Given an enqueued inbox message and a generated owner token.",
      "behavior": "Then ClaimAsync returns the message id and the row is marked Processing with the owner token.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 63,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithAvailableMessage_ClaimsSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then only one receives the message.",
      "intent": "Ensure exclusive claims under concurrent callers.",
      "scenario": "Given a single inbox message and two ClaimAsync calls with different owner tokens.",
      "behavior": "Then exactly one claim list contains the message id.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 97,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithConcurrentWorkers_EnsuresExclusiveClaims"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ClaimAsync is called with no pending messages, then it returns an empty set.",
      "intent": "Confirm the inbox work store returns no claims when there is no work.",
      "scenario": "Given an empty inbox table and a SqlInboxWorkStore instance.",
      "behavior": "Then ClaimAsync returns an empty list of message ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 45,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.ClaimAsync_WithNoMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called by the owner, then the message is marked Dead.",
      "intent": "Verify failed processing sets the inbox message to Dead.",
      "scenario": "Given a claimed inbox message and the owning token.",
      "behavior": "Then the row status is Dead and OwnerToken is cleared.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 193,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.FailAsync_WithClaimedMessage_MarksAsDead"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When GetAsync is called with an unknown message id, then it throws an InvalidOperationException.",
      "intent": "Ensure missing inbox messages result in a failure.",
      "scenario": "Given a SqlInboxWorkStore with no message matching the requested id.",
      "behavior": "Then GetAsync throws InvalidOperationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 284,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithInvalidMessageId_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When GetAsync is called with a valid message id, then it returns the stored message details.",
      "intent": "Verify inbox work store retrieval returns expected fields.",
      "scenario": "Given an enqueued inbox message with a known id.",
      "behavior": "Then GetAsync returns a message with matching id, source, topic, payload, and attempt.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 258,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.GetAsync_WithValidMessageId_ReturnsMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge a claim, then the message remains in Processing.",
      "intent": "Ensure owner token enforcement prevents unauthorized state changes.",
      "scenario": "Given a message claimed by one owner and AckAsync called with a different owner token.",
      "behavior": "Then the row status remains Processing with the original owner token.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/InboxWorkStoreTests.cs",
        "line": 225,
        "member": "Bravellian.Platform.Tests.InboxWorkStoreTests.OwnerTokenEnforcement_OnlyAllowsOperationsByOwner"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all join steps are completed, then HandleAsync marks the join as completed.",
      "intent": "Ensure successful joins transition to the Completed status.",
      "scenario": "Given a join expecting two steps with both steps marked complete.",
      "behavior": "Then the join status is updated to Completed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 144,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenAllStepsCompleted_MarksJoinAsCompleted"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenCompletedSuccessfully_EnqueuesFollowUpMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join completes with follow-up settings, then HandleAsync enqueues the follow-up outbox message.",
      "intent": "Verify that completion triggers an additional outbox message when configured.",
      "scenario": "Given a completed join and a JoinWaitPayload containing OnCompleteTopic and OnCompletePayload.",
      "behavior": "Then the outbox table contains a message with the follow-up topic.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 252,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenCompletedSuccessfully_EnqueuesFollowUpMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenFailIfAnyStepFailedIsFalse_CompletesEvenWithFailures",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FailIfAnyStepFailed is false, then HandleAsync completes the join even if some steps failed.",
      "intent": "Allow joins to complete successfully when failure tolerance is enabled.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed set to false.",
      "behavior": "Then the join status is updated to Completed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 361,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenFailIfAnyStepFailedIsFalse_CompletesEvenWithFailures"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinAlreadyCompleted_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join is already completed, then repeated HandleAsync calls leave it completed.",
      "intent": "Ensure join completion handling is idempotent.",
      "scenario": "Given a join already marked Completed and a join.wait message handled twice.",
      "behavior": "Then the join status remains Completed after both calls.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 309,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinAlreadyCompleted_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join has incomplete steps, then HandleAsync throws JoinNotReadyException.",
      "intent": "Prevent completion handling until all expected steps are finished.",
      "scenario": "Given a join expecting three steps with only one step marked complete and FailIfAnyStepFailed enabled.",
      "behavior": "Then the handler throws JoinNotReadyException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 97,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenJoinNotReady_ThrowsJoinNotReadyException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenSomeStepsFailed_MarksJoinAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When any join step fails and failures are not allowed, then HandleAsync marks the join as failed.",
      "intent": "Enforce failure propagation when FailIfAnyStepFailed is true.",
      "scenario": "Given a join with one completed step, one failed step, and FailIfAnyStepFailed enabled.",
      "behavior": "Then the join status is updated to Failed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/JoinWaitHandlerTests.cs",
        "line": 198,
        "member": "Bravellian.Platform.Tests.JoinWaitHandlerTests.HandleAsync_WhenSomeStepsFailed_MarksJoinAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is available, then AcquireAsync returns a runner with initialized state.",
      "intent": "Validate LeaseRunner acquisition returns a usable runner instance.",
      "scenario": "Given a unique lease name, owner, and lease duration using the real LeaseApi.",
      "behavior": "Then the runner is not null, has expected name/owner, and is not marked lost.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 58,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithAvailableLease_ReturnsRunnerInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second AcquireAsync returns null.",
      "intent": "Ensure LeaseRunner does not acquire a lease already owned by another runner.",
      "scenario": "Given owner1 acquires a lease and owner2 attempts to acquire the same lease immediately after.",
      "behavior": "Then the second acquisition returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 101,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.AcquireAsync_WithUnavailableLease_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.DisposedRunner_DoesNotRenew",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a runner is disposed, then TryRenewNowAsync returns false.",
      "intent": "Ensure disposed runners do not attempt renewals.",
      "scenario": "Given a LeaseRunner that has been disposed after acquisition.",
      "behavior": "Then TryRenewNowAsync returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 286,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.DisposedRunner_DoesNotRenew"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a custom renew percent is used, then automatic renewal keeps the runner valid past the threshold.",
      "intent": "Validate that automatic renewal triggers early enough to avoid lease loss.",
      "scenario": "Given a short lease duration with a 50% renew percent and a wait past half the duration.",
      "behavior": "Then the runner remains active and its cancellation token is not canceled.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 240,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.MonotonicRenewal_WithCustomRenewPercent_RenewsAtCorrectInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.RenewTimer_UsesMonotonicClockAcrossClockSkewAndGcPauses",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the monotonic clock jumps forward, then renewal scheduling advances based on monotonic time without over-renewing.",
      "intent": "Confirm renewal scheduling relies on monotonic time even across simulated pauses.",
      "scenario": "Given a LeaseRunner using a FakeMonotonicClock and reflection to inspect the next renewal timestamp.",
      "behavior": "Then the scheduled renewal time increases after the pause and remains stable on an immediate retry.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 327,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.RenewTimer_UsesMonotonicClockAcrossClockSkewAndGcPauses"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is still valid, then ThrowIfLost does not throw.",
      "intent": "Ensure the guard does not falsely signal a lost lease.",
      "scenario": "Given a LeaseRunner acquired with a valid lease and no renewal failures.",
      "behavior": "Then calling ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 200,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on a valid runner, then renewal succeeds and the lease is not lost.",
      "intent": "Confirm manual renewal succeeds for a current lease owner.",
      "scenario": "Given a LeaseRunner acquired with a valid lease and owner.",
      "behavior": "Then TryRenewNowAsync returns true and IsLost remains false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseRunnerTests.cs",
        "line": 156,
        "member": "Bravellian.Platform.Tests.LeaseRunnerTests.TryRenewNowAsync_WithValidRunner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a prior lease has expired, then a new owner can acquire it and receives a fresh expiry.",
      "intent": "Confirm expired leases can be reacquired by another owner.",
      "scenario": "Given a short lease acquired by owner1 and allowed to expire before owner2 acquires it.",
      "behavior": "Then AcquireAsync returns acquired true with a new lease expiry after server time.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 120,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithExpiredLease_SucceedsAndReturnsNewExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a free lease is acquired, then the acquisition succeeds and returns server time with a calculated expiry.",
      "intent": "Verify successful acquisition returns timing data from the server.",
      "scenario": "Given a new lease name, owner, and lease duration against the lease schema.",
      "behavior": "Then AcquireAsync returns acquired true with a non-default server time and an expiry near the expected duration.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithFreeResource_SucceedsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is already held, then a second acquisition attempt fails and returns server time without an expiry.",
      "intent": "Ensure AcquireAsync reports contention without granting a lease.",
      "scenario": "Given owner1 acquires the lease and owner2 attempts to acquire it before expiry.",
      "behavior": "Then AcquireAsync returns acquired false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.LeaseTests.AcquireAsync_WithOccupiedResource_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease has already expired, then renewal fails and no expiry is returned.",
      "intent": "Ensure expired leases cannot be renewed.",
      "scenario": "Given a short lease for an owner that is allowed to expire before renewal.",
      "behavior": "Then RenewAsync returns renewed false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 230,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithExpiredLease_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the current lease owner renews, then the lease is extended and server time advances.",
      "intent": "Validate successful renewals extend the lease window.",
      "scenario": "Given a lease acquired by a specific owner and a short delay before renewal.",
      "behavior": "Then RenewAsync returns renewed true with a later server time and a later lease expiry.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 158,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithValidOwner_SucceedsAndExtendsLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner attempts to renew a lease, then renewal fails and no expiry is returned.",
      "intent": "Prevent renewals from unauthorized owners.",
      "scenario": "Given owner1 acquires the lease and owner2 attempts to renew it.",
      "behavior": "Then RenewAsync returns renewed false with server time set and a null lease expiry.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/LeaseTests.cs",
        "line": 196,
        "member": "Bravellian.Platform.Tests.LeaseTests.RenewAsync_WithWrongOwner_FailsAndReturnsServerTime"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ManualSchemaExportTests.DeploySchemaAndExportToSqlProject",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "This manual test deploys all platform schemas to a fresh SQL Server container and then uses SqlPackage to extract the schema and update the SQL Server project. This test creates two separate databases and two separate dacpac files: 1. Control Plane database - contains Semaphore and Central Metrics schemas 2. Multi-Database schema - contains Outbox, Inbox, Scheduler, Lease, Fanout, Metrics, and DistributedLock schemas Note: This test is skipped by default to prevent it from running in CI. To run it, remove the Skip parameter or run it explicitly using the test filter.",
      "intent": "Provide a manual workflow for updating the SQL Server project from deployed schema.",
      "scenario": "Given an initialized SQL Server container and a valid connection string for schema deployment.",
      "behavior": "Then control plane and multi-database schemas are deployed and the extraction steps complete without error.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ManualSchemaExportTests.cs",
        "line": 79,
        "member": "Bravellian.Platform.Tests.ManualSchemaExportTests.DeploySchemaAndExportToSqlProject"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Percentiles",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a distribution of values is recorded, then percentile estimates are populated and within expected ranges.",
      "intent": "Validate percentile calculation for a known 1..100 data set.",
      "scenario": "Given a MetricAggregator that records integers 1 through 100.",
      "behavior": "Then P50, P95, and P99 are non-null and fall within expected ranges.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Percentiles"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Sum_And_Count",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot returns the correct sum and count.",
      "intent": "Verify aggregation totals across multiple recorded values.",
      "scenario": "Given a MetricAggregator that records three numeric values.",
      "behavior": "Then GetSnapshotAndReset reports sum 60 and count 3.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 29,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Calculate_Sum_And_Count"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Handle_Empty_State",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no values are recorded, then the snapshot reports zeros and null percentiles.",
      "intent": "Verify the empty state snapshot uses default aggregate values.",
      "scenario": "Given a new MetricAggregator with no recorded values.",
      "behavior": "Then GetSnapshotAndReset returns zero sum/count and null min/max/percentiles.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 141,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Handle_Empty_State"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Reset_After_Snapshot",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a snapshot is taken, then the aggregator resets its state for subsequent readings.",
      "intent": "Ensure GetSnapshotAndReset clears accumulated values.",
      "scenario": "Given a MetricAggregator that records two values and then snapshots twice.",
      "behavior": "Then the second snapshot returns zeros and nulls for all aggregates.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 117,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Reset_After_Snapshot"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Last_Value",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot keeps the last recorded value.",
      "intent": "Verify the aggregator tracks the most recent observation.",
      "scenario": "Given a MetricAggregator that records 10, 20, then 15.",
      "behavior": "Then GetSnapshotAndReset returns Last = 15.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 68,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Last_Value"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Min_And_Max",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When values are recorded, then the snapshot reports the minimum and maximum correctly.",
      "intent": "Ensure min/max tracking reflects the recorded range.",
      "scenario": "Given a MetricAggregator that records values 5, 15, 3, and 20.",
      "behavior": "Then GetSnapshotAndReset returns Min = 3 and Max = 20.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricAggregatorTests.cs",
        "line": 48,
        "member": "Bravellian.Platform.Tests.MetricAggregatorTests.Aggregator_Should_Track_Min_And_Max"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndAllowedTag_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a registered metric allows a tag, then IsTagAllowed returns true.",
      "intent": "Confirm allowed tags are honored for registered metrics.",
      "scenario": "Given a registered metric that includes the \u0022allowed_tag\u0022 value.",
      "behavior": "Then IsTagAllowed returns true for that tag.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 108,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndAllowedTag_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndDisallowedTag_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a registered metric does not allow a tag, then IsTagAllowed returns false.",
      "intent": "Ensure disallowed tags are rejected even for registered metrics.",
      "scenario": "Given a registered metric that only allows \u0022allowed_tag\u0022.",
      "behavior": "Then IsTagAllowed returns false for a different tag value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 133,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithRegisteredMetricAndDisallowedTag_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithUnregisteredMetric_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a metric is not registered, then IsTagAllowed returns false for any tag.",
      "intent": "Verify tag checks fail for unknown metrics.",
      "scenario": "Given a MetricRegistrar with no registration for \u0022unknown.metric\u0022.",
      "behavior": "Then IsTagAllowed returns false for the requested tag.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 158,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.IsTagAllowed_WithUnregisteredMetric_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.RegisterRange_WithMultipleMetrics_AddsAllToRegistry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple metrics are registered in bulk, then all of them appear in the registry.",
      "intent": "Verify RegisterRange registers each provided metric.",
      "scenario": "Given three MetricRegistration instances passed to RegisterRange.",
      "behavior": "Then GetAll returns three entries matching the metric names.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 80,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.RegisterRange_WithMultipleMetrics_AddsAllToRegistry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.Register_WithDuplicateMetric_LogsWarning",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same metric is registered twice, then the registry keeps a single entry.",
      "intent": "Ensure duplicate registration does not create duplicate entries.",
      "scenario": "Given a MetricRegistrar that registers the same metric twice.",
      "behavior": "Then GetAll returns one registration for the metric.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 54,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.Register_WithDuplicateMetric_LogsWarning"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricRegistrarTests.Register_WithValidMetric_AddsToRegistry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a valid metric is registered, then it appears in the registry.",
      "intent": "Verify MetricRegistrar stores new metric registrations.",
      "scenario": "Given a MetricRegistrar and a MetricRegistration for \u0022test.metric\u0022.",
      "behavior": "Then GetAll returns a single entry that matches the registered metric.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricRegistrarTests.cs",
        "line": 28,
        "member": "Bravellian.Platform.Tests.MetricRegistrarTests.Register_WithValidMetric_AddsToRegistry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricDef table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the metric definition table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricDef table.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricsSchemaTests.cs",
        "line": 44,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricDef_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricPointMinute table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the minute-bucket metric points table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricPointMinute table.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricsSchemaTests.cs",
        "line": 76,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricPointMinute_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the metrics schema is deployed, then the MetricSeries table exists in the infra schema.",
      "intent": "Verify the schema deployment creates the metric series table.",
      "scenario": "Given EnsureMetricsSchemaAsync has run and a SQL connection is open.",
      "behavior": "Then the information schema query returns one MetricSeries table.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricsSchemaTests.cs",
        "line": 60,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.MetricSeries_Table_Should_Exist"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.SpUpsertMetricPointMinute_Should_Insert_And_Update",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SpUpsertMetricPointMinute is called twice for the same bucket, then the row is updated additively.",
      "intent": "Validate the minute-bucket upsert merges sums, counts, and min/max/last values.",
      "scenario": "Given an existing series id and two upserts for the same bucket start time.",
      "behavior": "Then the MetricPointMinute row reflects summed counts, min/max, and last value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricsSchemaTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.SpUpsertMetricPointMinute_Should_Insert_And_Update"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MetricsSchemaTests.SpUpsertSeries_Should_Create_Series",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SpUpsertSeries executes with a new series definition, then it returns a positive series id.",
      "intent": "Confirm the series upsert procedure creates or locates a series record.",
      "scenario": "Given a SQL connection and parameters for a new metric series.",
      "behavior": "Then the output @SeriesId is greater than zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MetricsSchemaTests.cs",
        "line": 92,
        "member": "Bravellian.Platform.Tests.MetricsSchemaTests.SpUpsertSeries_Should_Create_Series"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based control plane registration is built, then configuration and discovery expose all tenant databases.",
      "intent": "Validate list-based control plane wiring and tenant discovery.",
      "scenario": "Given two tenant databases, a control plane database, and services configured with list-based registration.",
      "behavior": "Then the configuration reflects control plane settings and discovery/store providers return all tenants.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 56,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.ListRegistration_WiresControlPlaneAndDiscoversDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based multi-tenant outbox dispatch runs, then one message is processed per tenant.",
      "intent": "Validate outbox dispatch for discovery-based registration across multiple tenants.",
      "scenario": "Given two tenant databases, a control plane database, and a host configured with discovery-based registration.",
      "behavior": "Then each tenant outbox marks one message as processed after dispatch.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 174,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_MultipleTenants"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When discovery-based outbox dispatch runs for a single tenant, then the message is processed once.",
      "intent": "Confirm outbox dispatch works for a single tenant using discovery-based registration.",
      "scenario": "Given one tenant database, a control plane database, and a host configured with discovery-based registration.",
      "behavior": "Then the tenant outbox contains one processed message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 212,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_Discovery_SingleTenant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based multi-tenant outbox dispatch runs, then one message is processed per tenant.",
      "intent": "Ensure outbox dispatch processes tenant messages with list-based registration.",
      "scenario": "Given two tenant databases, a control plane database, and a host with a CapturingOutboxHandler sink.",
      "behavior": "Then each tenant payload is handled and each tenant outbox marks one row as processed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 100,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_MultipleTenants"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based outbox dispatch runs for a single tenant, then the message is processed once.",
      "intent": "Confirm outbox dispatch works for a single tenant using list-based registration.",
      "scenario": "Given one tenant database, a control plane database, and a host with a CapturingOutboxHandler sink.",
      "behavior": "Then the tenant outbox contains one processed message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiDatabaseControlPlaneIntegrationTests.cs",
        "line": 139,
        "member": "Bravellian.Platform.Tests.MultiDatabaseControlPlaneIntegrationTests.OutboxDispatch_List_SingleTenant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers share a lease router, then only one processes all inbox messages while the other is blocked.",
      "intent": "Confirm that lease-based coordination prevents concurrent processing across dispatchers.",
      "scenario": "Given an inbox table with five messages, a TestLeaseRouter, and two MultiInboxDispatcher instances using the same store.",
      "behavior": "Then one dispatcher processes all five messages and the other processes none, with a total of five processed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a dispatcher has no lease router, then it processes all available inbox messages.",
      "intent": "Validate that processing is unrestricted when lease coordination is disabled.",
      "scenario": "Given an inbox table with three messages and a MultiInboxDispatcher configured with a null lease router.",
      "behavior": "Then RunOnceAsync returns a count of three and the handler records three processed messages.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiInboxDispatcherLeaseTests.cs",
        "line": 172,
        "member": "Bravellian.Platform.Tests.MultiInboxDispatcherLeaseTests.MultiInboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two dispatchers run with a shared lease router, then only one processes the queued messages.",
      "intent": "Verify the lease gate prevents concurrent processing of the same outbox.",
      "scenario": "Given an outbox table with five messages, a lease router, and two dispatchers running concurrently.",
      "behavior": "Then one dispatcher processes all messages while the other processes none.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 44,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithLease_PreventsConcurrentProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dispatcher runs without a lease router, then it processes all available messages.",
      "intent": "Ensure outbox processing proceeds without lease coordination when disabled.",
      "scenario": "Given an outbox table with three messages and a dispatcher with no lease router.",
      "behavior": "Then RunOnceAsync returns three and all messages are handled.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiOutboxDispatcherLeaseTests.cs",
        "line": 155,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherLeaseTests.MultiOutboxDispatcher_WithoutLease_AllowsProcessing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the dispatcher runs across multiple stores, then it processes messages from each store.",
      "intent": "Validate multi-store dispatching with round-robin selection.",
      "scenario": "Given two outbox schemas with one ready message each and a round-robin strategy.",
      "behavior": "Then two runs process both messages and mark them as processed in each schema.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiOutboxDispatcherTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_ProcessesMessagesFromMultipleStores"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When using the drain-first strategy, then the dispatcher drains one store before moving on.",
      "intent": "Verify drain-first selection keeps working a store until it is empty.",
      "scenario": "Given a store with three ready messages and drain-first selection with batch size one.",
      "behavior": "Then successive runs process three messages and the fourth run returns zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/MultiOutboxDispatcherTests.cs",
        "line": 157,
        "member": "Bravellian.Platform.Tests.MultiOutboxDispatcherTests.MultiOutboxDispatcher_WithDrainFirstStrategy_DrainsOneStoreBeforeMoving"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_AllowsConfiguration",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformObservability is configured, then the options reflect the provided settings.",
      "intent": "Ensure custom observability options are bound into IOptions.",
      "scenario": "Given AddPlatformObservability invoked with a configuration delegate.",
      "behavior": "Then ObservabilityOptions exposes the configured metrics, logging, and scan period values.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 52,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_AllowsConfiguration"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_RegistersRequiredServices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformObservability is called, then watchdog services are registered in DI.",
      "intent": "Verify basic observability wiring registers the watchdog and hosted service.",
      "scenario": "Given a ServiceCollection with logging and AddPlatformObservability applied.",
      "behavior": "Then IWatchdog resolves and WatchdogService is present among hosted services.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 29,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.AddPlatformObservability_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddAlertSink",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an alert sink is added via the builder, then it is registered for resolution.",
      "intent": "Verify watchdog alert sinks can be registered through the builder.",
      "scenario": "Given AddPlatformObservability followed by AddWatchdogAlertSink with a delegate.",
      "behavior": "Then IWatchdogAlertSink services are present in DI.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 80,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddAlertSink"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHealthChecks",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When platform health checks are added via the builder, then the health check service is registered.",
      "intent": "Confirm health check registration is wired through observability setup.",
      "scenario": "Given AddPlatformObservability followed by AddPlatformHealthChecks.",
      "behavior": "Then HealthCheckService resolves from the service provider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHealthChecks"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHeartbeatSink",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a heartbeat sink is added via the builder, then it is registered for resolution.",
      "intent": "Verify heartbeat sinks can be registered through the observability builder.",
      "scenario": "Given AddPlatformObservability followed by AddHeartbeatSink with a delegate.",
      "behavior": "Then IHeartbeatSink services are present in DI.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 105,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.ObservabilityBuilder_CanAddHeartbeatSink"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.WatchdogAlertContext_ContainsAllRequiredFields",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a WatchdogAlertContext is created, then all supplied fields are preserved.",
      "intent": "Verify alert context carries kind, component, timestamps, and attributes.",
      "scenario": "Given a WatchdogAlertContext constructed with explicit values and attributes.",
      "behavior": "Then the properties match the provided inputs, including attribute entries.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 150,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.WatchdogAlertContext_ContainsAllRequiredFields"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.ObservabilityRegistrationTests.WatchdogSnapshot_ContainsAlerts",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a WatchdogSnapshot is created with alerts, then those alerts are retained.",
      "intent": "Ensure watchdog snapshots surface alert payloads and timestamps.",
      "scenario": "Given a WatchdogSnapshot constructed with one ActiveAlert and timestamps.",
      "behavior": "Then the snapshot contains the alert and preserves LastScanAt/LastHeartbeatAt.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/ObservabilityRegistrationTests.cs",
        "line": 184,
        "member": "Bravellian.Platform.Tests.ObservabilityRegistrationTests.WatchdogSnapshot_ContainsAlerts"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingConnectionString",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlFanout is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure fanout registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlFanoutOptions with a whitespace ConnectionString.",
      "behavior": "Then AddSqlFanout throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 129,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingSchemaName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlFanout is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure fanout registration requires a non-empty schema name.",
      "scenario": "Given SqlFanoutOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlFanout throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 145,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlFanout_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingConnectionString",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure inbox registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlInboxOptions with an empty ConnectionString.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 79,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingSchemaName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure inbox registration requires a non-empty schema name.",
      "scenario": "Given SqlInboxOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 95,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForZeroCleanupInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlInbox is called with cleanup enabled and a zero interval, then it throws an OptionsValidationException.",
      "intent": "Validate inbox cleanup interval must be greater than zero when enabled.",
      "scenario": "Given SqlInboxOptions with EnableAutomaticCleanup true and CleanupInterval set to TimeSpan.Zero.",
      "behavior": "Then AddSqlInbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlInbox_ThrowsForZeroCleanupInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingConnectionString",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with a missing connection string, then it throws an OptionsValidationException.",
      "intent": "Ensure outbox registration validates required connection string settings.",
      "scenario": "Given a ServiceCollection and SqlOutboxOptions with an empty ConnectionString.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 27,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingConnectionString"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingSchemaName",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with a missing schema name, then it throws an OptionsValidationException.",
      "intent": "Ensure outbox registration requires a non-empty schema name.",
      "scenario": "Given SqlOutboxOptions with a valid connection string and an empty SchemaName.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 112,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForMissingSchemaName"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForZeroCleanupInterval",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddSqlOutbox is called with cleanup enabled and a zero interval, then it throws an OptionsValidationException.",
      "intent": "Validate outbox cleanup interval must be greater than zero when enabled.",
      "scenario": "Given SqlOutboxOptions with EnableAutomaticCleanup true and CleanupInterval set to TimeSpan.Zero.",
      "behavior": "Then AddSqlOutbox throws OptionsValidationException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OptionsValidationTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.OptionsValidationTests.AddSqlOutbox_ThrowsForZeroCleanupInterval"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the cleanup stored procedure is missing, then the cleanup service runs without crashing.",
      "intent": "Ensure the outbox cleanup service tolerates missing schema deployment.",
      "scenario": "Given the cleanup procedure dropped and a short cleanup interval.",
      "behavior": "Then StartAsync completes without throwing and the procedure remains missing.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxCleanupTests.cs",
        "line": 221,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.CleanupService_GracefullyHandles_MissingStoredProcedure"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a retention window, then only processed outbox rows older than the window are deleted.",
      "intent": "Verify the outbox cleanup procedure removes stale processed rows.",
      "scenario": "Given old processed, recent processed, and unprocessed outbox rows before cleanup.",
      "behavior": "Then only the old processed message is deleted and other rows remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxCleanupTests.cs",
        "line": 45,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_DeletesOldProcessedMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs with a 10-day retention period, then only rows older than 10 days are deleted.",
      "intent": "Confirm retention period filtering for outbox cleanup.",
      "scenario": "Given processed outbox rows at 30, 15, 7, 3, and 1 days old.",
      "behavior": "Then only the 30- and 15-day rows are deleted and newer rows remain.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxCleanupTests.cs",
        "line": 163,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_RespectsRetentionPeriod"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cleanup runs and no processed rows are older than retention, then nothing is deleted.",
      "intent": "Ensure cleanup is a no-op when no rows qualify for deletion.",
      "scenario": "Given only a recent processed outbox row before cleanup.",
      "behavior": "Then the cleanup procedure deletes zero rows and the message remains.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxCleanupTests.cs",
        "line": 122,
        "member": "Bravellian.Platform.Tests.OutboxCleanupTests.Cleanup_WithNoOldMessages_DeletesNothing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with all parameters, then the join.wait payload persists those values.",
      "intent": "Verify join wait enqueue serializes all provided topics, payloads, and flags.",
      "scenario": "Given an outbox service with join support and explicit on-complete/on-fail details.",
      "behavior": "Then the persisted join.wait payload matches all provided parameters.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxExtensionsTests.cs",
        "line": 66,
        "member": "Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithAllParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithFailIfAnyStepFailedFalse_EnqueuesCorrectMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When failIfAnyStepFailed is false, then the payload preserves the false flag and provided completion topic.",
      "intent": "Ensure the fail-if-any-step flag is stored as provided.",
      "scenario": "Given an outbox service and EnqueueJoinWaitAsync called with failIfAnyStepFailed = false.",
      "behavior": "Then the join.wait payload has FailIfAnyStepFailed = false and the completion topic set.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxExtensionsTests.cs",
        "line": 143,
        "member": "Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithFailIfAnyStepFailedFalse_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnqueueJoinWaitAsync is called with only a join id, then defaults are applied in the payload.",
      "intent": "Confirm minimal arguments still produce a valid join.wait payload.",
      "scenario": "Given an outbox service and a generated JoinIdentifier.",
      "behavior": "Then the payload has FailIfAnyStepFailed = true and null on-complete/on-fail fields.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxExtensionsTests.cs",
        "line": 109,
        "member": "Bravellian.Platform.Tests.OutboxExtensionsTests.EnqueueJoinWaitAsync_WithMinimalParameters_EnqueuesCorrectMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When DefaultBackoff is computed for increasing attempts, then delays grow with jitter and are capped.",
      "intent": "Verify the default backoff function uses exponential growth with jitter bounds.",
      "scenario": "Given multiple attempt values passed to MultiOutboxDispatcher.DefaultBackoff.",
      "behavior": "Then delays fall within expected ranges and do not exceed the maximum cap.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 398,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_DefaultBackoff_ExponentialWithJitter"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler throws, then the dispatcher reschedules the message with a backoff delay.",
      "intent": "Verify failing handlers trigger reschedule with an error message.",
      "scenario": "Given a TestHandler configured to throw and a message with RetryCount \u003E 0.",
      "behavior": "Then the store records a reschedule with a positive delay and the handler error.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 177,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_HandlerThrows_ReschedulesWithBackoff"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When processing both a handled and an unhandled message, then logs are emitted at expected levels.",
      "intent": "Validate dispatcher logging includes information, debug, and warning entries.",
      "scenario": "Given a capturing logger, one message with a handler, and one without a handler.",
      "behavior": "Then log entries include Information for batch, Debug for processing, and Warning for no handler.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 329,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsAtCorrectLevels"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is processed successfully, then the dispatcher completes and dispatches it.",
      "intent": "Confirm the successful path results in handler execution and dispatch.",
      "scenario": "Given a TestOutboxStore with one message and a matching handler.",
      "behavior": "Then the handler is invoked once and the message is marked dispatched.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 255,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a handler fails, then the dispatcher records an error and reschedules the message.",
      "intent": "Ensure handler exceptions result in reschedule entries with errors.",
      "scenario": "Given a TestHandler that throws and a TestOutboxStore with one message.",
      "behavior": "Then the handler is invoked and the reschedule error contains the exception message.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 292,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_LogsErrors_WhenHandlerFails"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no handler exists for a message topic, then the dispatcher marks the message as failed.",
      "intent": "Ensure unknown topics fail fast instead of being rescheduled.",
      "scenario": "Given a TestOutboxStore with one message and an empty resolver.",
      "behavior": "Then RunOnceAsync records a failed message with a no-handler error.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 144,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_NoHandler_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a single outbox message has a matching handler, then it is processed and dispatched.",
      "intent": "Verify successful message handling marks the item as dispatched.",
      "scenario": "Given a TestOutboxStore with one message and a handler for its topic.",
      "behavior": "Then RunOnceAsync returns 1 and the store records a dispatched id.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 109,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_ProcessSingleMessage_Success"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message hits max attempts, then the dispatcher fails it instead of rescheduling.",
      "intent": "Ensure poison messages are failed when retries are exhausted.",
      "scenario": "Given a message with RetryCount = 2 and maxAttempts = 3 with a failing handler.",
      "behavior": "Then the message is added to FailedMessages and not rescheduled.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 216,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.MultiOutboxDispatcher_WithPoisonMessage_FailsWhenMaxAttemptsReached"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When handler topics are looked up with different casing, then the resolver still matches them.",
      "intent": "Ensure topic matching is case-insensitive.",
      "scenario": "Given a resolver with a handler for \u0022Email.Send\u0022 and lookups using different casing.",
      "behavior": "Then TryGet succeeds for lower-case and upper-case topic strings.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 90,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_CaseInsensitive"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the resolver is given handlers, then it resolves matching topics and rejects unknown ones.",
      "intent": "Validate handler lookup works for registered topics.",
      "scenario": "Given an OutboxHandlerResolver initialized with three TestHandler instances.",
      "behavior": "Then TryGet returns true for known topics and false for an unknown topic.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 63,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.OutboxHandlerResolver_WithHandlers_ResolvesCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddOutboxHandler is called with a factory, then it registers a singleton IOutboxHandler factory.",
      "intent": "Confirm DI registration for factory-based handler creation.",
      "scenario": "Given a ServiceCollection and AddOutboxHandler with a factory delegate.",
      "behavior": "Then the service descriptor contains an implementation factory with singleton lifetime.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 449,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_Factory_RegistersHandler"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxHandlerTests.cs",
        "line": 428,
        "member": "Bravellian.Platform.Tests.OutboxHandlerTests.ServiceCollection_AddOutboxHandler_RegistersHandler"
      },
      "status": "missing-required",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When attaching the same message twice, then only one join-member row exists.",
      "intent": "Ensure attaching a message is idempotent.",
      "scenario": "Create a join and message, then call AttachMessageToJoinAsync twice.",
      "behavior": "The OutboxJoinMember table still contains a single row for the pair.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 192,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_CalledTwice_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When attaching an outbox message to a join, then a join-member row is created.",
      "intent": "Verify join-member mappings are persisted.",
      "scenario": "Create a join and an outbox message, then attach the message to the join.",
      "behavior": "The OutboxJoinMember table contains one row for the join/message pair.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 160,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.AttachMessageToJoinAsync_WithValidIds_CreatesAssociation"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When all steps complete and status is set to Completed, then the join shows all completed and no failures.",
      "intent": "Verify end-to-end completion updates counts and status.",
      "scenario": "Create a join with three steps, attach three messages, increment completed for each, then set status to Completed.",
      "behavior": "The final join has Status Completed, CompletedSteps 3, and FailedSteps 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 356,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithAllStepsCompleted_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When some steps fail and status is set to Failed, then the join records completed and failed counts.",
      "intent": "Verify mixed completion and failure tracking.",
      "scenario": "Create a join with three steps, complete two, fail one, then set status to Failed.",
      "behavior": "The final join has Status Failed, CompletedSteps 2, and FailedSteps 1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 404,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CompleteJoinWorkflow_WithSomeStepsFailed_WorksCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When creating a join with tenant, expected steps, and metadata, then the join is pending with zero counts.",
      "intent": "Verify CreateJoinAsync persists default join state.",
      "scenario": "Create a join with tenantId 12345, expectedSteps 5, and metadata.",
      "behavior": "The join has a non-empty id, pending status, zero completed/failed, metadata, and a recent CreatedUtc.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 83,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.CreateJoinAsync_WithValidParameters_CreatesJoin"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join exists, then GetJoinAsync returns it with the expected steps.",
      "intent": "Ensure joins can be retrieved by id.",
      "scenario": "Create a join with expectedSteps 3 and fetch by JoinId.",
      "behavior": "The returned join is not null and matches JoinId and ExpectedSteps.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 116,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithExistingJoin_ReturnsJoin"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a join id is unknown, then GetJoinAsync returns null.",
      "intent": "Confirm missing joins return no result.",
      "scenario": "Generate a new JoinIdentifier without creating a join.",
      "behavior": "The retrieved join is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 141,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinAsync_WithNonExistentJoin_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple messages are attached to a join, then GetJoinMessagesAsync returns all message ids.",
      "intent": "Ensure join-member retrieval returns every attached message.",
      "scenario": "Create a join, attach three messages, then query join messages.",
      "behavior": "The result contains three ids including the attached message ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 322,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.GetJoinMessagesAsync_WithMultipleMessages_ReturnsAllMessageIds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IncrementCompletedAsync is called twice for the same message, then the completed count increases only once.",
      "intent": "Ensure completed increments are idempotent per message.",
      "scenario": "Create a join, attach a message, then call IncrementCompletedAsync twice.",
      "behavior": "The join reports CompletedSteps 1 and FailedSteps 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 445,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When completed increments exceed expected steps, then the completed count stops at the expected total.",
      "intent": "Ensure completed steps are capped by expected steps.",
      "scenario": "Create a join expecting two steps, attach three messages, then increment completed for all three.",
      "behavior": "The join reports CompletedSteps 2 and FailedSteps 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 501,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WhenTotalWouldExceedExpected_DoesNotOverCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a joined message is marked completed, then CompletedSteps increments and FailedSteps stays zero.",
      "intent": "Verify completed step increments update the join counters.",
      "scenario": "Create a join with expected steps, attach a message, then increment completed.",
      "behavior": "The join reports CompletedSteps 1, FailedSteps 0, and a newer LastUpdatedUtc.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 229,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementCompletedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When IncrementFailedAsync is called twice for the same message, then the failed count increases only once.",
      "intent": "Ensure failed increments are idempotent per message.",
      "scenario": "Create a join, attach a message, then call IncrementFailedAsync twice.",
      "behavior": "The join reports FailedSteps 1 and CompletedSteps 0.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 473,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_CalledTwiceForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a joined message is marked failed, then FailedSteps increments and CompletedSteps stays zero.",
      "intent": "Verify failed step increments update the join counters.",
      "scenario": "Create a join with expected steps, attach a message, then increment failed.",
      "behavior": "The join reports FailedSteps 1, CompletedSteps 0, and a newer LastUpdatedUtc.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 261,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.IncrementFailedAsync_WithValidMessage_IncrementsCount"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When outbox messages are acknowledged, then join completed counts increment per message.",
      "intent": "Verify outbox ack integration updates join progress.",
      "scenario": "Create a join with two messages, claim and ack each via stored procedures.",
      "behavior": "CompletedSteps increases to 1 after the first ack and to 2 after the second with no failures.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 538,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_AutomaticallyReportsJoinCompletion"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same message is acknowledged twice, then the join completed count does not increment again.",
      "intent": "Ensure duplicate acks do not double-count join completion.",
      "scenario": "Create a join with one message, ack it once, then ack it again with the same owner token.",
      "behavior": "The join still reports CompletedSteps 1 and FailedSteps 0 after the second ack.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 620,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxAck_MultipleAcksForSameMessage_IsIdempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an outbox message is failed, then join failure count increments alongside completed work.",
      "intent": "Verify outbox failure integration updates join failure counts.",
      "scenario": "Create a join with two messages, ack the first, then fail the second via stored procedure.",
      "behavior": "The join reports CompletedSteps 1 and FailedSteps 1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 582,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.OutboxFail_AutomaticallyReportsJoinFailure"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When updating join status, then the stored join status changes to the new value.",
      "intent": "Verify UpdateStatusAsync persists status changes.",
      "scenario": "Create a join, update status to Completed, then fetch the join.",
      "behavior": "The retrieved join has Status set to Completed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxJoinTests.cs",
        "line": 293,
        "member": "Bravellian.Platform.Tests.OutboxJoinTests.UpdateStatusAsync_WithValidStatus_UpdatesJoinStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_IsPublicSealedRecord",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When OutboxMessage is inspected, then it is a public sealed record-like class.",
      "intent": "Verify the OutboxMessage type characteristics (public, sealed, record semantics).",
      "scenario": "Given reflection checks against the OutboxMessage type.",
      "behavior": "Then the type is public, sealed, class-based, and has a virtual ToString.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxMessageTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_IsPublicSealedRecord"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_IsRecord_WithCorrectProperties",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the OutboxMessage type is inspected, then it exposes the expected core properties.",
      "intent": "Confirm the record exposes required outbox fields with correct types.",
      "scenario": "Given reflection over the OutboxMessage type.",
      "behavior": "Then Id, Topic, Payload, and CorrelationId properties exist with expected types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxMessageTests.cs",
        "line": 26,
        "member": "Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_IsRecord_WithCorrectProperties"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_Properties_HaveExpectedTypes",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When OutboxMessage properties are reflected, then each property has the expected CLR type.",
      "intent": "Validate type metadata for outbox message properties.",
      "scenario": "Given reflection over all OutboxMessage properties.",
      "behavior": "Then the property types match the expected identifier, string, and timestamp types.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxMessageTests.cs",
        "line": 62,
        "member": "Bravellian.Platform.Tests.OutboxMessageTests.OutboxMessage_Properties_HaveExpectedTypes"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery loads tenants, then the router resolves distinct outboxes per tenant.",
      "intent": "Validate dynamic discovery works with outbox routing.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery with two tenants and an initial provider refresh.",
      "behavior": "Then GetOutbox returns non-null, distinct outboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterIntegrationTests.cs",
        "line": 91,
        "member": "Bravellian.Platform.Tests.OutboxRouterIntegrationTests.DynamicDiscovery_RoutesToCorrectDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterIntegrationTests.MultiTenantScenario_CreateMessagesInDifferentDatabases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When tenant keys are routed, then each key resolves to a distinct outbox instance.",
      "intent": "Demonstrate multi-tenant routing for configured outbox stores.",
      "scenario": "Given two SqlOutboxOptions entries and a ConfiguredOutboxStoreProvider with FakeTimeProvider.",
      "behavior": "Then the router returns non-null, distinct outboxes for Tenant1 and Tenant2.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterIntegrationTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.Tests.OutboxRouterIntegrationTests.MultiTenantScenario_CreateMessagesInDifferentDatabases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterIntegrationTests.TypicalApplicationUsage_DemonstratesPattern",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a typical application requests outboxes by tenant, then it receives distinct tenant outboxes.",
      "intent": "Illustrate the routing pattern used by application services.",
      "scenario": "Given an OrderService using an OutboxRouter backed by configured tenant options.",
      "behavior": "Then TenantA and TenantB resolve to different outbox instances.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterIntegrationTests.cs",
        "line": 139,
        "member": "Bravellian.Platform.Tests.OutboxRouterIntegrationTests.TypicalApplicationUsage_DemonstratesPattern"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.DynamicProvider_AfterRefresh_NewOutboxIsAvailable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When discovery is refreshed after adding a tenant, then the new outbox becomes available.",
      "intent": "Ensure provider refresh picks up newly discovered databases.",
      "scenario": "Given a DynamicOutboxStoreProvider that refreshes after adding Tenant2.",
      "behavior": "Then GetOutbox returns a non-null outbox for the new tenant.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 241,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.DynamicProvider_AfterRefresh_NewOutboxIsAvailable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.DynamicProvider_GetOutboxByKey_ReturnsCorrectOutbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is used, then routing returns distinct outboxes per discovered tenant.",
      "intent": "Verify DynamicOutboxStoreProvider works with the router after discovery.",
      "scenario": "Given a SampleOutboxDatabaseDiscovery with two tenants and an initial provider refresh.",
      "behavior": "Then GetOutbox returns distinct non-null outboxes for both tenant identifiers.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 190,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.DynamicProvider_GetOutboxByKey_ReturnsCorrectOutbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_GuidKeyConvertsToString_ReturnsOutbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a Guid key does not match any configured identifier, then GetOutbox throws with the key in the message.",
      "intent": "Verify Guid-based lookup reports missing identifiers clearly.",
      "scenario": "Given a router configured for \u0022Customer1\u0022 and a different Guid key.",
      "behavior": "Then GetOutbox(Guid) throws InvalidOperationException containing the Guid string.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 321,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_GuidKeyConvertsToString_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_MultipleCallsForSameKey_ReturnsSameInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When GetOutbox is called multiple times for the same key, then it returns the same instance.",
      "intent": "Confirm outbox instances are cached per key.",
      "scenario": "Given a router configured with a single tenant key.",
      "behavior": "Then repeated GetOutbox calls return the same object instance.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 289,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_MultipleCallsForSameKey_ReturnsSameInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithEmptyKey_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an empty key is provided, then GetOutbox throws an ArgumentException.",
      "intent": "Validate input guarding for outbox routing.",
      "scenario": "Given a configured router and an empty string key.",
      "behavior": "Then GetOutbox throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 164,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithEmptyKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithGuidKey_ReturnsOutbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a Guid tenant key is requested, then the router resolves the matching outbox.",
      "intent": "Validate Guid overload routes by converting to string identifier.",
      "scenario": "Given a single SqlOutboxOptions entry keyed by a Guid string.",
      "behavior": "Then GetOutbox(Guid) returns a non-null outbox instance.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 81,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithGuidKey_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithNonExistentKey_ThrowsInvalidOperationException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an unknown tenant key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure the router fails for missing outbox keys.",
      "scenario": "Given a provider with one configured tenant and a non-existent key.",
      "behavior": "Then GetOutbox throws and the message mentions the key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 111,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithNonExistentKey_ThrowsInvalidOperationException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithNullKey_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a null key is provided, then GetOutbox throws an ArgumentException.",
      "intent": "Validate input guarding for outbox routing.",
      "scenario": "Given a configured router and a null string key.",
      "behavior": "Then GetOutbox throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 138,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithNullKey_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithStringKey_ReturnsOutbox",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When configured tenant keys are requested, then distinct outbox instances are returned.",
      "intent": "Verify routing by string key across multiple configured outbox stores.",
      "scenario": "Given two SqlOutboxOptions entries and a ConfiguredOutboxStoreProvider with a FakeTimeProvider.",
      "behavior": "Then GetOutbox returns non-null, distinct outbox instances for each tenant key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxRouterTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.OutboxRouterTests.GetOutbox_WithStringKey_ReturnsOutbox"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When two workers claim concurrently, then the claimed sets do not overlap.",
      "intent": "Validate exclusive claiming across concurrent workers.",
      "scenario": "Given ten ready items and two ClaimAsync calls with different owner tokens.",
      "behavior": "Then the combined results have no overlapping ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 175,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.ConcurrentClaim_MultipleWorkers_NoOverlap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge items, then the items remain InProgress.",
      "intent": "Ensure owner token enforcement prevents unauthorized updates.",
      "scenario": "Given claimed items and AckAsync called with a different owner token.",
      "behavior": "Then the items remain in Status = InProgress.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 203,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.InvalidOwnerOperations_DoNotAffectItems"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called by the owner, then outbox items return to Ready status.",
      "intent": "Ensure abandoned items are made available for reprocessing.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Ready.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 115,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAbandon_WithValidOwner_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called by the owner, then outbox items are marked Done and processed.",
      "intent": "Verify successful acknowledgements update outbox status and processed flag.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Done and IsProcessed = true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 95,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxAck_WithValidOwner_MarksDoneAndProcessed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ClaimAsync is called with a batch size, then it limits the number of claimed ids.",
      "intent": "Ensure batch size is respected in outbox claims.",
      "scenario": "Given five ready outbox rows and a batch size of two.",
      "behavior": "Then ClaimAsync returns exactly two ids.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithBatchSize_RespectsLimit"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ready outbox items exist, then ClaimAsync returns their ids.",
      "intent": "Verify work-queue claims return the ready items.",
      "scenario": "Given three outbox rows in Ready status and a generated owner token.",
      "behavior": "Then ClaimAsync returns three ids from the inserted set.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 57,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxClaim_WithReadyItems_ReturnsClaimedIds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called by the owner, then outbox items are marked Failed.",
      "intent": "Verify failure paths update status correctly.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Failed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 134,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxFail_WithValidOwner_MarksAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When leases expire, then ReapExpiredAsync returns items to Ready status.",
      "intent": "Ensure expired claims are reaped and made available again.",
      "scenario": "Given a claimed item with a 1-second lease and a delay past expiry.",
      "behavior": "Then the item status is reset to Ready after reaping.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkQueueTests.cs",
        "line": 153,
        "member": "Bravellian.Platform.Tests.OutboxWorkQueueTests.OutboxReapExpired_WithExpiredItems_ReturnsToReady"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AbandonAsync is called manually, then claimed items return to Ready.",
      "intent": "Ensure manual abandon resets outbox item state.",
      "scenario": "Given claimed outbox items and the owning token.",
      "behavior": "Then the items have Status = Ready.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 171,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Manual_AbandonOperation_Works"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple workers claim concurrently, then no outbox item is claimed more than once.",
      "intent": "Validate concurrency safety of the claim operation.",
      "scenario": "Given ten ready items and five concurrent ClaimAsync calls.",
      "behavior": "Then all claimed ids are unique and do not exceed available items.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 308,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_ConcurrentClaims_NoOverlap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync, AbandonAsync, or FailAsync are called with empty id lists, then they complete without error.",
      "intent": "Verify empty batch operations are safe no-ops.",
      "scenario": "Given an empty list of OutboxWorkItemIdentifier values.",
      "behavior": "Then the operations complete without throwing.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 291,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_EmptyIdLists_NoErrors"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AckAsync is called multiple times for the same items, then no errors occur and status remains Done.",
      "intent": "Verify acknowledgements are idempotent.",
      "scenario": "Given claimed items and multiple AckAsync calls with the same owner token.",
      "behavior": "Then the items remain in Status = Done.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 250,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_IdempotentOperations_NoErrors"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a claim lease expires and is reaped, then another owner can reclaim the item.",
      "intent": "Verify lease expiration allows subsequent claims.",
      "scenario": "Given a 1-second lease, a reap after expiry, and a second owner token.",
      "behavior": "Then the second owner claims the same item successfully.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 192,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_LeaseExpiration_AllowsReclaim"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is reaped and re-claimed, then the new owner token is persisted.",
      "intent": "Ensure owner token updates after lease expiration and re-claim.",
      "scenario": "Given a claim by owner1, a reap after expiry, and a new claim by owner2.",
      "behavior": "Then the database OwnerToken reflects owner2 for the reclaimed item.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_RestartUsesNewOwnerTokenAfterReap"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a non-owner tries to acknowledge items, then the items remain InProgress.",
      "intent": "Ensure owner token enforcement prevents unauthorized modifications.",
      "scenario": "Given claimed items owned by owner1 and AckAsync called by owner2.",
      "behavior": "Then the items stay InProgress under owner1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 271,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.WorkQueue_UnauthorizedOwner_CannotModify"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When items are claimed directly, then they enter InProgress and the claims match existing ids.",
      "intent": "Validate ClaimAsync returns known items and updates status.",
      "scenario": "Given two ready outbox items and a generated owner token.",
      "behavior": "Then the returned ids match the inserted items and have Status = InProgress.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 150,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ClaimsItemsCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the worker processes claimed items, then it acknowledges them and they become Done.",
      "intent": "Validate the outbox worker completes and acknowledges messages.",
      "scenario": "Given three ready outbox items and a running TestOutboxWorker.",
      "behavior": "Then all items are processed and marked Done in the database.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 98,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_ProcessesClaimedItems_AndAcknowledgesThem"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cancellation is requested, then the worker stops promptly.",
      "intent": "Ensure the outbox worker cooperates with cancellation tokens.",
      "scenario": "Given a TestOutboxWorker with a long processing delay and a short cancellation timeout.",
      "behavior": "Then the worker stops in under five seconds.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 336,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_RespectsCancellationToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the worker fails to process items, then it abandons them back to Ready.",
      "intent": "Ensure failures result in abandon operations rather than acknowledgements.",
      "scenario": "Given a TestOutboxWorker configured to fail processing and a short processing delay.",
      "behavior": "Then the claimed items return to Ready status.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/OutboxWorkerTests.cs",
        "line": 124,
        "member": "Bravellian.Platform.Tests.OutboxWorkerTests.Worker_WithProcessingFailure_AbandonsItems"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformFanout_RegistersPlatformProvider",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformFanout is registered, then the fanout repository provider resolves as the platform implementation.",
      "intent": "Confirm platform fanout registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IFanoutRepositoryProvider yields PlatformFanoutRepositoryProvider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformFeatureAdapterTests.cs",
        "line": 78,
        "member": "Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformFanout_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformInbox_RegistersPlatformProvider",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformInbox is registered, then the inbox work store provider resolves as the platform implementation.",
      "intent": "Confirm platform inbox registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IInboxWorkStoreProvider yields PlatformInboxWorkStoreProvider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformFeatureAdapterTests.cs",
        "line": 44,
        "member": "Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformInbox_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformLeases_RegistersPlatformProvider",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformLeases is registered, then the lease factory provider resolves as the platform implementation.",
      "intent": "Confirm platform lease registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving ILeaseFactoryProvider yields PlatformLeaseFactoryProvider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformFeatureAdapterTests.cs",
        "line": 95,
        "member": "Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformLeases_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformOutbox_RegistersPlatformProvider",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformOutbox is registered, then the outbox store provider resolves as the platform implementation.",
      "intent": "Confirm platform outbox registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving IOutboxStoreProvider yields PlatformOutboxStoreProvider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformFeatureAdapterTests.cs",
        "line": 27,
        "member": "Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformOutbox_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformScheduler_RegistersPlatformProvider",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformScheduler is registered, then the scheduler store provider resolves as the platform implementation.",
      "intent": "Confirm platform scheduler registration binds the provider to the platform adapter.",
      "scenario": "Given a service collection configured with a stub discovery and platform configuration.",
      "behavior": "Then resolving ISchedulerStoreProvider yields PlatformSchedulerStoreProvider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformFeatureAdapterTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.PlatformFeatureAdapterTests.AddPlatformScheduler_RegistersPlatformProvider"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscoveryAndControlPlane_AndNoDatabases_DoesNotThrowException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery uses a control plane and no app databases exist yet, then StartAsync fails for control plane validation rather than missing databases.",
      "intent": "Ensure control plane validation is reported distinctly from discovery emptiness.",
      "scenario": "Given UsesDiscovery true, a control plane connection string, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync throws an InvalidOperationException mentioning the control plane and not the missing database requirement.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformLifecycleServiceTests.cs",
        "line": 104,
        "member": "Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscoveryAndControlPlane_AndNoDatabases_DoesNotThrowException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndNoDatabases_DoesNotThrowException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery is enabled and startup does not require databases, then StartAsync completes without throwing.",
      "intent": "Allow zero databases at startup for dynamic discovery.",
      "scenario": "Given a configuration with UsesDiscovery true, RequiresDatabaseAtStartup false, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync returns without exceptions.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformLifecycleServiceTests.cs",
        "line": 37,
        "member": "Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndNoDatabases_DoesNotThrowException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndOneDatabase_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When dynamic discovery returns at least one database, then StartAsync completes without throwing.",
      "intent": "Allow startup with dynamic discovery when a database is discoverable.",
      "scenario": "Given UsesDiscovery true and a TestDatabaseDiscovery that returns one database.",
      "behavior": "Then StartAsync completes successfully.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformLifecycleServiceTests.cs",
        "line": 143,
        "member": "Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithDynamicDiscovery_AndOneDatabase_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndNoDatabases_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based discovery requires databases but none are found, then StartAsync throws with a missing database message.",
      "intent": "Enforce startup database requirements for list-based discovery.",
      "scenario": "Given UsesDiscovery false, RequiresDatabaseAtStartup true, and an EmptyDatabaseDiscovery.",
      "behavior": "Then StartAsync throws an InvalidOperationException containing \u0022At least one database is required\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformLifecycleServiceTests.cs",
        "line": 69,
        "member": "Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndNoDatabases_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndOneDatabase_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When list-based discovery provides at least one database, then StartAsync completes without throwing.",
      "intent": "Allow startup with list-based discovery when a database is configured.",
      "scenario": "Given UsesDiscovery false and a TestDatabaseDiscovery that returns one database.",
      "behavior": "Then StartAsync completes successfully.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformLifecycleServiceTests.cs",
        "line": 183,
        "member": "Bravellian.Platform.Tests.PlatformLifecycleServiceTests.StartAsync_WithListBasedDiscovery_AndOneDatabase_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsDlqMetrics",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected DLQ metrics.",
      "intent": "Verify that dead-letter queue metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes DLQ depth and oldest age metrics.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 108,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsDlqMetrics"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsInboxMetrics",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected inbox metrics.",
      "intent": "Verify that inbox metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes inbox processed, retry, failed, and processing latency metrics.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 83,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsInboxMetrics"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsOutboxMetrics",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it contains the expected outbox metrics.",
      "intent": "Verify that outbox metrics are registered in the catalog.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then the list includes outbox published, pending, oldest age, and latency metrics.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 58,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ContainsOutboxMetrics"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_CounterMetricsHaveCountUnit",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When counter metrics are selected from the catalog, then their units are count except for latency or age metrics.",
      "intent": "Validate unit conventions for counter metrics.",
      "scenario": "Given PlatformMetricCatalog.All is filtered to counter aggregation metrics.",
      "behavior": "Then non-latency and non-age counters use the Count unit.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 162,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_CounterMetricsHaveCountUnit"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_HistogramMetricsHaveTimeUnits",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When histogram metrics are selected from the catalog, then their units are time-based.",
      "intent": "Ensure histogram metrics report timing in milliseconds or seconds.",
      "scenario": "Given PlatformMetricCatalog.All is filtered to histogram aggregation metrics.",
      "behavior": "Then each histogram metric uses Milliseconds or Seconds units.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 193,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_HistogramMetricsHaveTimeUnits"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_MetricsHaveValidProperties",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then each metric has required metadata populated.",
      "intent": "Ensure metric definitions have valid names, units, descriptions, tags, and aggregation kinds.",
      "scenario": "Given PlatformMetricCatalog.All is evaluated.",
      "behavior": "Then each metric has non-empty name/unit/description, non-null tags, and a defined aggregation kind.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 131,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_MetricsHaveValidProperties"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ReturnsNonEmptyList",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the platform metric catalog is enumerated, then it returns a non-empty list.",
      "intent": "Ensure the catalog exposes at least one metric.",
      "scenario": "Given PlatformMetricCatalog.All is accessed without additional setup.",
      "behavior": "Then the returned list is not null and contains entries.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformMetricCatalogTests.cs",
        "line": 35,
        "member": "Bravellian.Platform.Tests.PlatformMetricCatalogTests.All_ReturnsNonEmptyList"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectInboxStoreRegistered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IInboxWorkStore registration, then it throws an InvalidOperationException.",
      "intent": "Prevent mixing direct inbox store registrations with platform discovery mode.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IInboxWorkStore registered.",
      "behavior": "Then AddPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct stores.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 248,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectInboxStoreRegistered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxRegistered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IOutbox registration, then it throws an InvalidOperationException.",
      "intent": "Ensure direct outbox services are not registered alongside platform discovery.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IOutbox registered.",
      "behavior": "Then AddPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct outboxes.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 272,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxRegistered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxStoreRegistered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When control-plane discovery registration finds a direct IOutboxStore registration, then it throws an InvalidOperationException.",
      "intent": "Prevent mixing direct outbox store registrations with platform discovery mode.",
      "scenario": "Given a service collection with a discovery implementation and a dummy IOutboxStore registered.",
      "behavior": "Then AddPlatformMultiDatabaseWithControlPlaneAndDiscovery throws with a message about direct stores.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 224,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithControlPlaneAndDiscovery_ThrowsWhenDirectOutboxStoreRegistered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithDiscovery_RegistersRequiredServices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformMultiDatabaseWithDiscovery is used, then configuration is set for discovery-based multi-database mode.",
      "intent": "Verify discovery-based registration flips the UsesDiscovery flag.",
      "scenario": "Given a service collection with a test IPlatformDatabaseDiscovery implementation.",
      "behavior": "Then PlatformConfiguration indicates multi-database without control and UsesDiscovery is true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 154,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithDiscovery_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_CalledTwice_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformMultiDatabaseWithList is called twice, then it throws an InvalidOperationException.",
      "intent": "Prevent duplicate multi-database list registration.",
      "scenario": "Given a service collection that already called AddPlatformMultiDatabaseWithList once.",
      "behavior": "Then the second call throws and the message mentions it was already called.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 64,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_CalledTwice_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_DuplicateNames_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformMultiDatabaseWithList receives duplicate database names, then it throws an ArgumentException.",
      "intent": "Ensure database identifiers are unique in list-based registration.",
      "scenario": "Given two PlatformDatabase entries with the same Name value.",
      "behavior": "Then AddPlatformMultiDatabaseWithList throws during discovery setup.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 134,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_DuplicateNames_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_EmptyList_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AddPlatformMultiDatabaseWithList receives an empty list, then it throws an ArgumentException.",
      "intent": "Guard against registering multi-database services without any databases.",
      "scenario": "Given an empty PlatformDatabase array passed to AddPlatformMultiDatabaseWithList.",
      "behavior": "Then an ArgumentException is thrown with a message indicating the list must not be empty.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 116,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_EmptyList_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_RegistersRequiredServices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple databases are registered via AddPlatformMultiDatabaseWithList, then platform configuration and discovery are registered.",
      "intent": "Ensure list-based registration sets multi-database configuration without discovery mode.",
      "scenario": "Given two PlatformDatabase entries passed to AddPlatformMultiDatabaseWithList.",
      "behavior": "Then PlatformConfiguration is set for multi-database without control and discovery resolves.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 88,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_SingleDatabase_RegistersRequiredServices",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a single database is registered via AddPlatformMultiDatabaseWithList, then core configuration and time abstractions are registered.",
      "intent": "Verify the multi-database list registration sets configuration, discovery, and timing services.",
      "scenario": "Given a service collection configured with one PlatformDatabase entry.",
      "behavior": "Then PlatformConfiguration, IPlatformDatabaseDiscovery, TimeProvider, and IMonotonicClock resolve with expected flags.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 29,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.AddPlatformMultiDatabaseWithList_SingleDatabase_RegistersRequiredServices"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.PlatformRegistrationTests.ListBasedDatabaseDiscovery_ReturnsConfiguredDatabasesAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When ListBasedDatabaseDiscovery is queried, then it returns the configured databases as-is.",
      "intent": "Confirm list-based discovery surfaces the configured database metadata.",
      "scenario": "Given a ListBasedDatabaseDiscovery initialized with two database entries.",
      "behavior": "Then DiscoverDatabasesAsync returns both entries with matching names and connection strings.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/PlatformRegistrationTests.cs",
        "line": 177,
        "member": "Bravellian.Platform.Tests.PlatformRegistrationTests.ListBasedDatabaseDiscovery_ReturnsConfiguredDatabasesAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.Reset_ResetsToFirstStore",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When Reset is called, then the next selection starts from the first store.",
      "intent": "Validate that reset clears the round-robin cursor.",
      "scenario": "Given a strategy that has already advanced through mock stores.",
      "behavior": "Then SelectNext returns the first store after Reset.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 86,
        "member": "Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.Reset_ResetsToFirstStore"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_CyclesThroughStores",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called repeatedly, then it cycles through stores in order and wraps around.",
      "intent": "Ensure round-robin selection advances deterministically through the store list.",
      "scenario": "Given three mock stores and successive SelectNext calls with the previously selected store.",
      "behavior": "Then the strategy returns store1, store2, store3, then wraps back to store1.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 61,
        "member": "Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_CyclesThroughStores"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SelectNext is called with no stores, then it returns null.",
      "intent": "Verify the round-robin strategy handles empty inputs safely.",
      "scenario": "Given an empty store list and a new RoundRobinOutboxSelectionStrategy instance.",
      "behavior": "Then SelectNext returns null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/RoundRobinSelectionStrategyTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.RoundRobinSelectionStrategyTests.SelectNext_WithNoStores_ReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchedulerMetricsTests.WorkQueueMetrics_Should_Be_Registered",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SchedulerMetrics is referenced, then all work-queue metric definitions are initialized.",
      "intent": "Verify scheduler work-queue metrics are registered and available.",
      "scenario": "Given access to the SchedulerMetrics static properties.",
      "behavior": "Then all inbox/outbox and timing metrics are non-null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchedulerMetricsTests.cs",
        "line": 24,
        "member": "Bravellian.Platform.Tests.SchedulerMetricsTests.WorkQueueMetrics_Should_Be_Registered"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithGuidKey_ReturnsSchedulerClient",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a Guid key is requested, then the router returns a scheduler client for the matching identifier string.",
      "intent": "Verify Guid overload routes by string conversion.",
      "scenario": "Given a scheduler config with an Identifier set to a Guid string.",
      "behavior": "Then GetSchedulerClient returns a SqlSchedulerClient for that Guid.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchedulerRouterTests.cs",
        "line": 133,
        "member": "Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithGuidKey_ReturnsSchedulerClient"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithInvalidKey_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an unknown scheduler key is requested, then the router throws an InvalidOperationException.",
      "intent": "Ensure invalid identifiers fail fast when no scheduler is configured.",
      "scenario": "Given a ConfiguredSchedulerStoreProvider with one configured database.",
      "behavior": "Then GetSchedulerClient throws for an unknown key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchedulerRouterTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithInvalidKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithNullKey_ThrowsException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an empty scheduler key is requested, then the router throws an ArgumentException.",
      "intent": "Validate key input guarding for scheduler routing.",
      "scenario": "Given a router configured with one scheduler store.",
      "behavior": "Then GetSchedulerClient throws for an empty string key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchedulerRouterTests.cs",
        "line": 105,
        "member": "Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithNullKey_ThrowsException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithValidKey_ReturnsSchedulerClient",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a known scheduler key is requested, then the router returns a scheduler client.",
      "intent": "Verify routing to a configured scheduler store by string key.",
      "scenario": "Given a ConfiguredSchedulerStoreProvider with two database configs and a test logger.",
      "behavior": "Then GetSchedulerClient returns a SqlSchedulerClient for the matching identifier.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchedulerRouterTests.cs",
        "line": 40,
        "member": "Bravellian.Platform.Tests.SchedulerRouterTests.SchedulerRouter_WithValidKey_ReturnsSchedulerClient"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SchemaVersionSnapshotTests.SchemaVersions_MatchSnapshot",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the schema snapshot is captured, then it matches the stored snapshot file.",
      "intent": "Verify schema version snapshots remain consistent across runs.",
      "scenario": "Given a captured schema snapshot and the existing snapshot file (or a refreshed snapshot).",
      "behavior": "Then the captured snapshot equals the stored snapshot content.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SchemaVersionSnapshotTests.cs",
        "line": 27,
        "member": "Bravellian.Platform.Tests.SchemaVersionSnapshotTests.SchemaVersions_MatchSnapshot"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentReapAndAcquire_MaintainsCorrectness",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When reaping and acquiring concurrently, then deletions stay within expired count and acquires stay under limit.",
      "intent": "Verify reaping and acquiring interleave safely.",
      "scenario": "Create expired leases, then run ReapExpiredAsync alongside new acquire attempts.",
      "behavior": "The deleted count is at most the expired leases and acquired count does not exceed the limit.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 261,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentReapAndAcquire_MaintainsCorrectness"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentUpdateLimit_DoesNotCorruptState",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When limits are updated concurrently, then the semaphore remains usable.",
      "intent": "Ensure concurrent limit updates do not corrupt semaphore state.",
      "scenario": "Apply multiple UpdateLimitAsync calls in parallel, then attempt an acquire.",
      "behavior": "The acquire returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 222,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ConcurrentUpdateLimit_DoesNotCorruptState"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.FencingCounters_StrictlyIncreasingUnderConcurrency",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring concurrently, then fencing counters are unique and strictly increasing.",
      "intent": "Ensure fencing counters remain ordered under concurrency.",
      "scenario": "Run 20 parallel acquires and collect fencing counters.",
      "behavior": "All counters are unique and strictly increasing when ordered.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 318,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.FencingCounters_StrictlyIncreasingUnderConcurrency"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.HighContentionAcquire_EventuallySucceeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When workers retry under contention, then most eventually acquire a lease.",
      "intent": "Verify retries succeed with short TTLs under high contention.",
      "scenario": "Run 10 workers with retries against a limit-2 semaphore.",
      "behavior": "More than half of workers report successful acquisition.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 172,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.HighContentionAcquire_EventuallySucceeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquireAndRelease_MaintainsInvariant",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When workers acquire and release concurrently, then releases match successful acquires.",
      "intent": "Ensure no leases are leaked under parallel acquire/release.",
      "scenario": "Run 20 workers that acquire, hold briefly, and release on a limit-5 semaphore.",
      "behavior": "The successful release count equals the successful acquire count.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 114,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquireAndRelease_MaintainsInvariant"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquires_NeverExceedsLimit",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When many workers acquire in parallel, then total acquisitions do not exceed the limit.",
      "intent": "Verify concurrent acquisition respects semaphore capacity.",
      "scenario": "Ensure a semaphore with limit 10 and run 50 parallel acquire attempts.",
      "behavior": "The number of acquired tokens is at most 10 and greater than zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 67,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.ParallelAcquires_NeverExceedsLimit"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.Renewals_WithIntermittentGcPausesMaintainLeases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When leases are renewed with jitter and pauses, then all renewals succeed.",
      "intent": "Validate renewals tolerate intermittent delays.",
      "scenario": "Acquire three leases and renew each with jitter and a simulated GC pause.",
      "behavior": "Every renewal result reports Renewed.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 363,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.Renewals_WithIntermittentGcPausesMaintainLeases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreConcurrencyTests.StarvedAcquisition_AppliesBackpressureUntilCapacityReturns",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore is saturated, then contenders are backpressured until capacity returns.",
      "intent": "Ensure contention produces backpressure and recovery once released.",
      "scenario": "Hold a lease while contenders retry, then release and attempt a recovery acquire.",
      "behavior": "NotAcquired attempts occur and the recovery acquire succeeds.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreConcurrencyTests.cs",
        "line": 431,
        "member": "Bravellian.Platform.Tests.SemaphoreConcurrencyTests.StarvedAcquisition_AppliesBackpressureUntilCapacityReturns"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreRegistrationTests.SemaphoreService_NotRegistered_InMultiDatabaseWithoutControlPlane",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multi-database registration omits a control plane, then ISemaphoreService is not registered.",
      "intent": "Ensure semaphore services remain global and require a control plane.",
      "scenario": "Given AddPlatformMultiDatabaseWithList called without control-plane options.",
      "behavior": "Then ISemaphoreService is not present in the service provider.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreRegistrationTests.cs",
        "line": 55,
        "member": "Bravellian.Platform.Tests.SemaphoreRegistrationTests.SemaphoreService_NotRegistered_InMultiDatabaseWithoutControlPlane"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitAboveMaximum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnsureExistsAsync receives a limit above maximum, then it throws ArgumentException.",
      "intent": "Enforce maximum semaphore limit.",
      "scenario": "Call EnsureExistsAsync with limit 10001.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 750,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitAboveMaximum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitBelowMinimum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When EnsureExistsAsync receives a limit below minimum, then it throws ArgumentException.",
      "intent": "Enforce minimum semaphore limit.",
      "scenario": "Call EnsureExistsAsync with limit 0.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 732,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.EnsureExists_LimitBelowMinimum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Fencing_StrictlyIncreases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When multiple leases are acquired, then fencing counters strictly increase.",
      "intent": "Verify fencing counters are monotonic across acquires.",
      "scenario": "Acquire five leases sequentially and record fencing counters.",
      "behavior": "Each fencing counter is greater than the previous one.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 287,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Fencing_StrictlyIncreases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.MultipleNames_AreIsolated",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring leases for different semaphore names, then each name is isolated.",
      "intent": "Verify semaphore names do not share capacity.",
      "scenario": "Create two named semaphores and acquire one lease from each.",
      "behavior": "Both acquisitions succeed and tokens differ.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 772,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.MultipleNames_AreIsolated"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_RemovesExpiredLeases",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When reaping expired leases, then expired rows are deleted.",
      "intent": "Validate ReapExpiredAsync removes expired leases.",
      "scenario": "Acquire multiple leases with short TTLs, wait for expiry, then reap.",
      "behavior": "The deleted count equals the number of expired leases.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 386,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_RemovesExpiredLeases"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_WithMaxRows_LimitsDeletions",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When reaping with a max row limit, then deletions are capped to that limit.",
      "intent": "Ensure ReapExpiredAsync respects the maxRows parameter.",
      "scenario": "Acquire several short-lived leases, wait for expiry, then reap with maxRows 2.",
      "behavior": "The first reap deletes 2 leases and the next reap deletes the remainder.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 420,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.ReapExpired_WithMaxRows_LimitsDeletions"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Release_FreesCapacity",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then a new acquire can succeed.",
      "intent": "Verify ReleaseAsync frees capacity for new leases.",
      "scenario": "Acquire a lease on a limit-1 semaphore, release it, then attempt another acquire.",
      "behavior": "The release succeeds and the second acquire is Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 152,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Release_FreesCapacity"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Release_IdempotentWhenCalledTwice",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same token is released twice, then the second release reports NotFound.",
      "intent": "Ensure ReleaseAsync is idempotent.",
      "scenario": "Acquire a lease and call ReleaseAsync twice with the same token.",
      "behavior": "The first release is Released and the second is NotFound.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 188,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Release_IdempotentWhenCalledTwice"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_AfterRelease_ReturnsLost",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing after a release, then the lease is reported as lost.",
      "intent": "Ensure released tokens cannot be renewed.",
      "scenario": "Acquire a lease, release it, then attempt to renew the same token.",
      "behavior": "The renew result status is Lost.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 254,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_AfterRelease_ReturnsLost"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_ExtendsLeaseExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing an active lease, then the expiry moves forward.",
      "intent": "Verify RenewAsync extends the lease expiration.",
      "scenario": "Acquire a lease, wait briefly, then renew with the same TTL.",
      "behavior": "The renew result is Renewed and ExpiresAtUtc is later than the original.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 221,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_ExtendsLeaseExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_MonotonicExtension_NeverShortensExpiry",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When renewing with a shorter TTL, then the expiry does not move backward.",
      "intent": "Ensure RenewAsync enforces a monotonic expiry.",
      "scenario": "Acquire a lease with TTL 60 and renew it with TTL 10.",
      "behavior": "The renewed ExpiresAtUtc is greater than or equal to the original.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 317,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.Renew_MonotonicExtension_NeverShortensExpiry"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_AfterExpiry_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease expires, then a subsequent acquire succeeds.",
      "intent": "Verify expired leases free capacity for new acquisitions.",
      "scenario": "Acquire with a short TTL, wait for expiry, then attempt another acquire.",
      "behavior": "The second acquire returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 352,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_AfterExpiry_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_BeyondLimit_ReturnsNotAcquired",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquisitions exceed the limit, then additional acquire attempts return NotAcquired.",
      "intent": "Ensure the semaphore blocks acquisitions beyond capacity.",
      "scenario": "Ensure a semaphore with limit 2, acquire twice, then attempt a third acquire.",
      "behavior": "The third attempt returns NotAcquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_BeyondLimit_ReturnsNotAcquired"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidNameCharacters_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name contains invalid characters, then TryAcquireAsync throws ArgumentException.",
      "intent": "Reject invalid semaphore name characters.",
      "scenario": "Call TryAcquireAsync with names containing spaces or punctuation like @ or #.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 675,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidNameCharacters_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidName_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name is empty or whitespace, then TryAcquireAsync throws ArgumentException.",
      "intent": "Validate semaphore name input is required.",
      "scenario": "Call TryAcquireAsync with invalid name inputs from InlineData.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 609,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_InvalidName_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_NameTooLong_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name exceeds the maximum length, then TryAcquireAsync throws ArgumentException.",
      "intent": "Enforce maximum semaphore name length.",
      "scenario": "Call TryAcquireAsync with a 201-character name.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 626,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_NameTooLong_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlAboveMaximum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the TTL exceeds the maximum, then TryAcquireAsync throws ArgumentException.",
      "intent": "Validate maximum TTL constraints.",
      "scenario": "Ensure a semaphore exists and call TryAcquireAsync with TTL 3601.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 712,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlAboveMaximum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlBelowMinimum_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the TTL is below the minimum, then TryAcquireAsync throws ArgumentException.",
      "intent": "Validate minimum TTL constraints.",
      "scenario": "Ensure a semaphore exists and call TryAcquireAsync with TTL 0.",
      "behavior": "An ArgumentException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 692,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_TtlBelowMinimum_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_UpToLimit_AllAcquiresSucceed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring up to the configured limit, then each acquisition succeeds with unique tokens.",
      "intent": "Verify limit enforcement allows acquisitions up to capacity.",
      "scenario": "Ensure a semaphore with limit 3 and acquire three times with different owners.",
      "behavior": "All results are Acquired with unique tokens and fencing values.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 89,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_UpToLimit_AllAcquiresSucceed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_ValidNameCharacters_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the semaphore name uses allowed characters, then TryAcquireAsync succeeds.",
      "intent": "Verify valid name patterns are accepted.",
      "scenario": "Ensure semaphores exist for valid names and call TryAcquireAsync.",
      "behavior": "Each attempt returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 651,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_ValidNameCharacters_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithNonExistentSemaphore_ReturnsNotAcquired",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring a semaphore that has not been created, then status is NotAcquired.",
      "intent": "Confirm missing semaphores are not implicitly created.",
      "scenario": "Use a new semaphore name without calling EnsureExistsAsync.",
      "behavior": "TryAcquireAsync returns NotAcquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 68,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithNonExistentSemaphore_ReturnsNotAcquired"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithSameClientRequestId_ReturnsExistingLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring twice with the same client request id, then the same lease is returned.",
      "intent": "Verify TryAcquireAsync is idempotent by client request id.",
      "scenario": "Call TryAcquireAsync twice with the same clientRequestId.",
      "behavior": "The second result matches the first token and fencing values.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 568,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.TryAcquire_WithSameClientRequestId_ReturnsExistingLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Decrease_BlocksNewAcquires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the limit is decreased below active count, then new acquires are blocked until capacity frees.",
      "intent": "Ensure UpdateLimitAsync enforces the lowered limit.",
      "scenario": "Acquire two leases, lower limit to one, attempt acquires after each release.",
      "behavior": "Acquires are NotAcquired while at the limit and succeed after both releases.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 501,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Decrease_BlocksNewAcquires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Increase_EnablesMoreAcquires",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the limit is increased, then additional acquires can succeed.",
      "intent": "Verify UpdateLimitAsync expands capacity.",
      "scenario": "Acquire at limit 1, update limit to 2, then acquire again.",
      "behavior": "The second acquire returns Acquired.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SemaphoreServiceTests.cs",
        "line": 465,
        "member": "Bravellian.Platform.Tests.SemaphoreServiceTests.UpdateLimit_Increase_EnablesMoreAcquires"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called with a hash, then the hash is persisted in the inbox row.",
      "intent": "Verify the optional hash is stored for deduplication checks.",
      "scenario": "Given a message id, source, and a 32-byte hash.",
      "behavior": "Then the stored Hash column matches the provided bytes.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 219,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithHash_StoresHashCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an invalid message id is provided, then AlreadyProcessedAsync throws an ArgumentException.",
      "intent": "Ensure inbox checks validate message id inputs.",
      "scenario": "Given null or empty message id values.",
      "behavior": "Then AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 248,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidMessageId_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When an invalid source is provided, then AlreadyProcessedAsync throws an ArgumentException.",
      "intent": "Ensure inbox checks validate source inputs.",
      "scenario": "Given null or empty source values.",
      "behavior": "Then AlreadyProcessedAsync throws ArgumentException.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 265,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithInvalidSource_ThrowsArgumentException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new message id is checked, then AlreadyProcessedAsync returns false and records it.",
      "intent": "Verify first-time inbox checks persist the message record.",
      "scenario": "Given a SqlInboxService and a new message id/source pair.",
      "behavior": "Then AlreadyProcessedAsync returns false and a row exists in infra.Inbox.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 37,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithNewMessage_ReturnsFalseAndRecordsMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message has been marked processed, then AlreadyProcessedAsync returns true.",
      "intent": "Confirm processed messages are reported as already processed.",
      "scenario": "Given a message recorded and marked processed via MarkProcessedAsync.",
      "behavior": "Then a subsequent AlreadyProcessedAsync returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 66,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.AlreadyProcessedAsync_WithProcessedMessage_ReturnsTrue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AlreadyProcessedAsync is called concurrently for the same message, then one row is created and attempts increment.",
      "intent": "Ensure concurrent checks remain idempotent and track attempts.",
      "scenario": "Given five concurrent AlreadyProcessedAsync calls for the same message id.",
      "behavior": "Then all calls return false, only one row exists, and Attempts equals five.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 177,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.ConcurrentAlreadyProcessedAsync_WithSameMessage_HandledCorrectly"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.MarkDeadAsync_UpdatesStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkDeadAsync is called, then the message status becomes Dead.",
      "intent": "Confirm dead-lettering updates the status field.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row status is Dead.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 148,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.MarkDeadAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessedAsync is called, then ProcessedUtc is set and status becomes Done.",
      "intent": "Verify processed state updates both timestamp and status.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row has non-null ProcessedUtc and Status = Done.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 89,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.MarkProcessedAsync_SetsProcessedUtcAndStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlInboxServiceTests.MarkProcessingAsync_UpdatesStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkProcessingAsync is called, then the message status becomes Processing.",
      "intent": "Confirm processing state transitions update the status field.",
      "scenario": "Given a recorded inbox message.",
      "behavior": "Then the database row status is Processing.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlInboxServiceTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.SqlInboxServiceTests.MarkProcessingAsync_UpdatesStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.Constructor_CreatesInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When constructing the outbox service, then it provides an IOutbox implementation.",
      "intent": "Verify SqlOutboxService instantiation succeeds.",
      "scenario": "Create a SqlOutboxService with default options and a null logger.",
      "behavior": "The service is not null and is assignable to IOutbox.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 49,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.Constructor_CreatesInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing multiple messages in one transaction, then all rows are inserted.",
      "intent": "Verify batch inserts within a transaction.",
      "scenario": "Enqueue three messages using the same transaction.",
      "behavior": "The outbox table contains three rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 228,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue targets a missing table, then the table is created and the message is inserted.",
      "intent": "Ensure standalone enqueue creates the outbox table if needed.",
      "scenario": "Drop the custom table, then enqueue using a service pointing at that table.",
      "behavior": "The custom table exists and contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 391,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_EnsuresTableExists"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing multiple standalone messages, then all rows are inserted.",
      "intent": "Verify standalone enqueue handles multiple writes.",
      "scenario": "Enqueue three messages with unique topic/payload suffixes.",
      "behavior": "The outbox table contains three matching rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 349,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_MultipleMessages_AllInsertedSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When standalone enqueue uses a null correlation id, then the message is inserted.",
      "intent": "Allow null correlation ids in standalone enqueue.",
      "scenario": "Call EnqueueAsync with topic, payload, and a null correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 314,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing without an explicit transaction, then the message is inserted.",
      "intent": "Verify standalone enqueue creates an outbox record.",
      "scenario": "Call EnqueueAsync with topic, payload, and correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 277,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_Standalone_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When using custom schema and table options, then the message is inserted into that table.",
      "intent": "Ensure custom outbox table routing is honored.",
      "scenario": "Create a custom schema/table and enqueue a message using a custom outbox service.",
      "behavior": "The custom table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 98,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithCustomSchemaAndTable_InsertsMessageToCorrectTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing with a null correlation id, then the message is still inserted.",
      "intent": "Allow null correlation ids during transactional enqueue.",
      "scenario": "Enqueue a message with topic and payload and a null correlation id.",
      "behavior": "The outbox table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 150,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullCorrelationId_InsertsMessageSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the transaction is null, then EnqueueAsync throws ArgumentNullException.",
      "intent": "Enforce a non-null transaction for transactional enqueue.",
      "scenario": "Call EnqueueAsync with a null IDbTransaction.",
      "behavior": "An ArgumentNullException is thrown.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 257,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithNullTransaction_ThrowsNullReferenceException"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing with a transaction, then a matching outbox row is inserted.",
      "intent": "Validate enqueue persists messages within a transaction.",
      "scenario": "Open a SQL transaction, enqueue a message with topic, payload, and correlation id.",
      "behavior": "The outbox table contains exactly one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 64,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_InsertsMessageToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When enqueueing a message, then default outbox columns are initialized.",
      "intent": "Verify insert defaults for processing metadata.",
      "scenario": "Enqueue a message in a transaction and read the inserted row.",
      "behavior": "IsProcessed is false, ProcessedAt is null, RetryCount is 0, CreatedAt is recent, and MessageId is set.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxServiceTests.cs",
        "line": 183,
        "member": "Bravellian.Platform.Tests.SqlOutboxServiceTests.EnqueueAsync_WithValidParameters_SetsDefaultValues"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithDueMessages_ReturnsMessages",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a due message exists, then ClaimDueAsync returns it with expected fields.",
      "intent": "Ensure due outbox rows are claimed and materialized correctly.",
      "scenario": "Given a ready outbox row created five minutes ago.",
      "behavior": "Then ClaimDueAsync returns one message with matching id, topic, and payload.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 67,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithDueMessages_ReturnsMessages"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithFutureMessages_ReturnsEmpty",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a message is scheduled for the future, then ClaimDueAsync does not return it.",
      "intent": "Verify scheduled messages are not claimed before their due time.",
      "scenario": "Given a ready outbox row with DueTimeUtc set in the future.",
      "behavior": "Then ClaimDueAsync returns an empty list.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 103,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithFutureMessages_ReturnsEmpty"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithNoMessages_ReturnsEmptyList",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no due messages exist, then ClaimDueAsync returns an empty list.",
      "intent": "Verify the outbox store does not return items when the queue is empty.",
      "scenario": "Given an empty outbox table and a SqlOutboxStore instance.",
      "behavior": "Then ClaimDueAsync returns zero messages.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 53,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.ClaimDueAsync_WithNoMessages_ReturnsEmptyList"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.FailAsync_MarksMessageAsFailed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FailAsync is called, then the message is marked Failed with error details.",
      "intent": "Ensure permanent failures set status and error metadata.",
      "scenario": "Given a claimed outbox message and an error message.",
      "behavior": "Then the row status is Failed and LastError/ProcessedBy are populated.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 225,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.FailAsync_MarksMessageAsFailed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.MarkDispatchedAsync_UpdatesMessage",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MarkDispatchedAsync is called, then the message is marked Done and processed.",
      "intent": "Confirm dispatch updates status and IsProcessed.",
      "scenario": "Given a claimed outbox message id.",
      "behavior": "Then the row status is Done and IsProcessed is true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 137,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.MarkDispatchedAsync_UpdatesMessage"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlOutboxStoreTests.RescheduleAsync_UpdatesRetryCountAndNextAttempt",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When RescheduleAsync is called, then retry count increments and last error is recorded.",
      "intent": "Verify rescheduling updates retry metadata and leaves the item ready.",
      "scenario": "Given a claimed outbox message with RetryCount = 2 and a backoff delay.",
      "behavior": "Then RetryCount becomes 3, LastError is set, and Status is Ready.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlOutboxStoreTests.cs",
        "line": 179,
        "member": "Bravellian.Platform.Tests.SqlOutboxStoreTests.RescheduleAsync_UpdatesRetryCountAndNextAttempt"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithNonexistentTimerId_ReturnsFalse",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cancelling a missing timer id, then CancelTimerAsync returns false.",
      "intent": "Confirm cancel is a no-op for unknown timers.",
      "scenario": "Call CancelTimerAsync with a random Guid string.",
      "behavior": "The result is false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 212,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithNonexistentTimerId_ReturnsFalse"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithValidTimerId_UpdatesTimerStatus",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When cancelling an existing timer, then CancelTimerAsync returns true and status is Cancelled.",
      "intent": "Verify cancellation updates stored timer status.",
      "scenario": "Schedule a timer, then cancel it by id.",
      "behavior": "CancelTimerAsync returns true and the timer status is Cancelled.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 181,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.CancelTimerAsync_WithValidTimerId_UpdatesTimerStatus"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When constructing the scheduler client, then it provides an ISchedulerClient implementation.",
      "intent": "Verify SqlSchedulerClient instantiation succeeds.",
      "scenario": "Create a SqlSchedulerClient with default options and TimeProvider.System.",
      "behavior": "The client is not null and is assignable to ISchedulerClient.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 47,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.Constructor_WithValidConnectionString_CreatesInstance"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a job already exists, then CreateOrUpdateJobAsync updates it without duplication.",
      "intent": "Verify upsert behavior for existing jobs.",
      "scenario": "Create a job, then call CreateOrUpdateJobAsync again with a new topic.",
      "behavior": "The job count remains one and the topic is updated.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 286,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_ExistingJob_UpdatesJob"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_InsertsJobSuccessfully",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When creating a job with a null payload, then the stored payload remains null.",
      "intent": "Allow null payloads when defining jobs.",
      "scenario": "Create a job with payload set to null.",
      "behavior": "The payload column is DBNull for the job.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 260,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithNullPayload_InsertsJobSuccessfully"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithValidParameters_InsertsJobToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When creating a job, then a job row is inserted with name, topic, and cron schedule.",
      "intent": "Validate CreateOrUpdateJobAsync persists new jobs.",
      "scenario": "Create a job with name, topic, cron, and payload.",
      "behavior": "The jobs table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 230,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.CreateOrUpdateJobAsync_WithValidParameters_InsertsJobToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When deleting an existing job, then the job row is removed.",
      "intent": "Verify DeleteJobAsync removes jobs by name.",
      "scenario": "Create a job and then delete it by name.",
      "behavior": "The jobs table contains zero matching rows.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 324,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.DeleteJobAsync_WithValidJobName_RemovesJob"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When custom scheduler table names are used, then timers are stored in the custom table.",
      "intent": "Ensure ScheduleTimerAsync honors custom table options.",
      "scenario": "Create custom schema/tables and schedule a timer with the custom client.",
      "behavior": "The custom timers table contains one matching row.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 94,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithCustomTableNames_InsertsToCorrectTable"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then a timer row with the topic is inserted.",
      "intent": "Validate ScheduleTimerAsync persists timers.",
      "scenario": "Schedule a timer with topic, payload, and due time.",
      "behavior": "The returned id is a Guid and one matching timer row exists.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 63,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_InsertsTimerToDatabase"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_SetsCorrectDefaults",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When scheduling a timer, then default timer columns are initialized.",
      "intent": "Verify default status and metadata values on insert.",
      "scenario": "Schedule a timer and read the stored row.",
      "behavior": "Status is Pending, ClaimedBy/ClaimedAt are null, RetryCount is 0, and CreatedAt is recent.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 146,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.ScheduleTimerAsync_WithValidParameters_SetsCorrectDefaults"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When triggering a job, then a job run is created for that job.",
      "intent": "Ensure TriggerJobAsync records a job run.",
      "scenario": "Create a job and trigger it by name.",
      "behavior": "The job runs table contains at least one row for the job.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlSchedulerClientTests.cs",
        "line": 352,
        "member": "Bravellian.Platform.Tests.SqlSchedulerClientTests.TriggerJobAsync_WithValidJobName_CreatesJobRun"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SqlScriptDeploymentTests.SqlArtifacts_DeployInOrder",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When SQL artifacts are applied in order, then all scripts execute without errors.",
      "intent": "Verify the ordered SQL script set can be deployed sequentially.",
      "scenario": "Given a new test database and the ordered SQL script list from the database folder.",
      "behavior": "Then each script batch executes successfully in sequence.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SqlScriptDeploymentTests.cs",
        "line": 37,
        "member": "Bravellian.Platform.Tests.SqlScriptDeploymentTests.SqlArtifacts_DeployInOrder"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is released, then the resource can be acquired again with a higher fencing token.",
      "intent": "Validate lease release frees the resource for subsequent acquisition.",
      "scenario": "Given a resource acquired once, then disposed, and acquired again.",
      "behavior": "Then the second lease succeeds and has a higher fencing token.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 107,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_AfterLeaseReleased_CanAcquireAgain"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the same owner token acquires a lease twice, then both acquisitions succeed with increasing fencing tokens.",
      "intent": "Validate re-entrant acquisition with the same owner token.",
      "scenario": "Given two AcquireAsync calls for the same resource using the same OwnerToken.",
      "behavior": "Then both leases are non-null and the second fencing token is greater than the first.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 237,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_ReentrantWithSameOwnerToken_Succeeds"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When AcquireAsync is called twice for the same resource, then the second call returns null.",
      "intent": "Ensure a lease cannot be acquired concurrently for the same resource.",
      "scenario": "Given a SqlLeaseFactory and two sequential AcquireAsync calls for the same resource.",
      "behavior": "Then the first lease is non-null and the second result is null.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 84,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_SameResourceTwice_SecondCallReturnsNull"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a custom owner token is provided, then the acquired lease uses that token.",
      "intent": "Verify custom owner tokens are honored by AcquireAsync.",
      "scenario": "Given AcquireAsync invoked with a specific OwnerToken value.",
      "behavior": "Then the lease OwnerToken equals the supplied token.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 212,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithCustomOwnerToken_UsesProvidedToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When acquiring leases for different resources, then both acquisitions succeed independently.",
      "intent": "Ensure leases are isolated per resource name.",
      "scenario": "Given two distinct resource names acquired sequentially.",
      "behavior": "Then both leases are non-null with matching resource names and distinct owner tokens.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 184,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithDifferentResources_BothSucceed"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is acquired for a new resource, then a valid lease instance is returned.",
      "intent": "Verify AcquireAsync produces a lease with expected identifiers and fencing token.",
      "scenario": "Given a SqlLeaseFactory and a unique resource name.",
      "behavior": "Then the lease has a non-empty owner token, positive fencing token, and matching resource name.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 59,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.AcquireAsync_WithValidResource_CanAcquireLease"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a lease is still valid, then ThrowIfLost does not throw.",
      "intent": "Verify lost-lease guard does not trigger for active leases.",
      "scenario": "Given an acquired lease that has not expired or been released.",
      "behavior": "Then calling ThrowIfLost completes without exception.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 163,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.ThrowIfLost_WhenLeaseIsValid_DoesNotThrow"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When TryRenewNowAsync is called on an active lease, then it succeeds and increments the fencing token.",
      "intent": "Ensure renewals advance the fencing token for valid leases.",
      "scenario": "Given an acquired lease and its initial fencing token value.",
      "behavior": "Then TryRenewNowAsync returns true and the fencing token increases.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/SystemLeaseTests.cs",
        "line": 136,
        "member": "Bravellian.Platform.Tests.SystemLeaseTests.TryRenewNowAsync_WithValidLease_SucceedsAndIncrementsFencingToken"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.FakeTimeProvider_CanBeUsedForTesting",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When FakeTimeProvider is advanced, then GetUtcNow reflects the new time.",
      "intent": "Demonstrate deterministic time control with FakeTimeProvider.",
      "scenario": "Given a FakeTimeProvider initialized to a fixed instant.",
      "behavior": "Then advancing by one hour updates GetUtcNow by one hour.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 99,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.FakeTimeProvider_CanBeUsedForTesting"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsFalseWhenNotReached",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a deadline is in the future, then Expired returns false.",
      "intent": "Verify MonoDeadline reports not expired before the deadline.",
      "scenario": "Given a MonoDeadline one hour in the future and the same clock.",
      "behavior": "Then Expired returns false.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 63,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsFalseWhenNotReached"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsTrueWhenReached",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a deadline is in the past, then Expired returns true.",
      "intent": "Verify MonoDeadline reports expired once the deadline is reached.",
      "scenario": "Given a MonoDeadline set to one second before the current clock time.",
      "behavior": "Then Expired returns true.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 81,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_Expired_ReturnsTrueWhenReached"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_WorksWithFakeMonotonicClock",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a fake monotonic clock advances past a deadline, then Expired flips to true.",
      "intent": "Verify MonoDeadline works with a controllable monotonic clock.",
      "scenario": "Given a FakeMonotonicClock and a deadline 10 seconds in the future.",
      "behavior": "Then Expired is false before the advance and true after advancing 15 seconds.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 119,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.MonoDeadline_WorksWithFakeMonotonicClock"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.MonotonicClock_Seconds_ReturnsPositiveValue",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MonotonicClock seconds are read, then the value is positive.",
      "intent": "Ensure the monotonic clock exposes a positive elapsed seconds value.",
      "scenario": "Given a new MonotonicClock instance.",
      "behavior": "Then Seconds is greater than zero.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 46,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.MonotonicClock_Seconds_ReturnsPositiveValue"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.TimeAbstractionTests.MonotonicClock_Ticks_ReturnsIncreasingValues",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When MonotonicClock ticks are read twice, then the second value is not less than the first.",
      "intent": "Verify monotonic ticks do not move backwards.",
      "scenario": "Given a new MonotonicClock instance.",
      "behavior": "Then the second tick reading is greater than or equal to the first.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/TimeAbstractionTests.cs",
        "line": 28,
        "member": "Bravellian.Platform.Tests.TimeAbstractionTests.MonotonicClock_Ticks_ReturnsIncreasingValues"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.WatchdogServiceTests.GetSnapshot_ReturnsInitialState",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When a new WatchdogService is created, then its snapshot is empty and timestamps equal the initial time.",
      "intent": "Verify the watchdog snapshot starts with no alerts.",
      "scenario": "Given a WatchdogService configured with a FakeTimeProvider and no sinks.",
      "behavior": "Then GetSnapshot returns empty alerts and timestamps equal the initial fake time.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/WatchdogServiceTests.cs",
        "line": 31,
        "member": "Bravellian.Platform.Tests.WatchdogServiceTests.GetSnapshot_ReturnsInitialState"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogHealthCheck_ReturnsHealthy_WhenNoAlertsAsync",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When no alerts are present, then the watchdog health check reports Healthy.",
      "intent": "Validate health check status reflects an alert-free snapshot.",
      "scenario": "Given a WatchdogService with no alert sinks and no active alerts.",
      "behavior": "Then WatchdogHealthCheck returns Healthy.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/WatchdogServiceTests.cs",
        "line": 190,
        "member": "Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogHealthCheck_ReturnsHealthy_WhenNoAlertsAsync"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogService_DetectsOverdueJobs",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When overdue jobs are reported by the scheduler state, then the watchdog emits an overdue-job alert.",
      "intent": "Verify job-overdue detection triggers alert sinks.",
      "scenario": "Given a FakeSchedulerState with an overdue job and a DelegateAlertSink.",
      "behavior": "Then an OverdueJob alert is emitted with the job id.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/WatchdogServiceTests.cs",
        "line": 127,
        "member": "Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogService_DetectsOverdueJobs"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogService_EmitsHeartbeat",
      "category": "Bravellian.Platform.Tests",
      "tags": [],
      "summary": "When the heartbeat period elapses, then the watchdog emits a heartbeat to sinks.",
      "intent": "Ensure heartbeat scheduling triggers sink callbacks.",
      "scenario": "Given a WatchdogService with a DelegateHeartbeatSink and FakeTimeProvider advanced past heartbeat period.",
      "behavior": "Then the heartbeat sink is invoked with a sequence number.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/WatchdogServiceTests.cs",
        "line": 66,
        "member": "Bravellian.Platform.Tests.WatchdogServiceTests.WatchdogService_EmitsHeartbeat"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Engine_descriptors_must_use_module_key",
      "category": "Modularity",
      "tags": [],
      "summary": "When an engine descriptor uses a different module key, then AddModuleServices throws.",
      "intent": "Guard against mismatched module and engine descriptor keys.",
      "scenario": "Given ModuleWithMismatchedEngineDescriptor is registered and no required configuration is needed.",
      "behavior": "Then AddModuleServices throws and the error references the engine descriptor module key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 174,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Engine_descriptors_must_use_module_key"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_unique",
      "category": "Modularity",
      "tags": [],
      "summary": "When multiple modules share the same key, then AddModuleServices throws an InvalidOperationException.",
      "intent": "Enforce unique module keys during registration.",
      "scenario": "Given SampleModule and ConflictingModule are registered with the same key and required configuration is provided.",
      "behavior": "Then AddModuleServices throws due to the duplicate module key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 110,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_unique"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_url_safe",
      "category": "Modularity",
      "tags": [],
      "summary": "When a module key contains a slash, then AddModuleServices throws with a URL-safety message.",
      "intent": "Ensure module keys are URL-safe for routing and metadata.",
      "scenario": "Given ModuleWithInvalidKey is registered and its required configuration key is supplied.",
      "behavior": "Then AddModuleServices throws and the error mentions that keys cannot contain slashes.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 142,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Module_keys_must_be_url_safe"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Modules_are_registered_in_di",
      "category": "Modularity",
      "tags": [],
      "summary": "When module services are added, then the module definition is registered in DI.",
      "intent": "Ensure module definitions are accessible through the service provider.",
      "scenario": "Given SampleModule is registered and configuration includes its required key.",
      "behavior": "Then resolving IModuleDefinition returns a module with key \u0022sample-module\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 77,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Modules_are_registered_in_di"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Modules_register_services_and_health",
      "category": "Modularity",
      "tags": [],
      "summary": "When a module is registered with its required configuration, then its services and health checks are added to DI.",
      "intent": "Verify that module registration wires up services and health checks.",
      "scenario": "Given SampleModule is registered and configuration provides its required key.",
      "behavior": "Then MarkerService is resolvable and the health check registration includes \u0022sample_module\u0022.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 42,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Modules_register_services_and_health"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Registering_module_type_is_idempotent",
      "category": "Modularity",
      "tags": [],
      "summary": "When the same module type is registered twice, then the second registration is ignored without error.",
      "intent": "Confirm ModuleRegistry.RegisterModule is idempotent for identical types.",
      "scenario": "Given ModuleRegistry already contains SampleModule.",
      "behavior": "Then registering SampleModule again does not throw.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 227,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Registering_module_type_is_idempotent"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Webhook_metadata_must_be_unique",
      "category": "Modularity",
      "tags": [],
      "summary": "When two modules register identical webhook metadata, then AddModuleServices throws.",
      "intent": "Prevent conflicting webhook metadata registrations across modules.",
      "scenario": "Given WebhookModuleOne and WebhookModuleTwo declare the same webhook metadata.",
      "behavior": "Then AddModuleServices throws and the message indicates the webhook is already handled.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/ModuleSystemTests.cs",
        "line": 200,
        "member": "Bravellian.Platform.Tests.Modularity.ModuleSystemTests.Webhook_metadata_must_be_unique"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_invokes_module_configuration",
      "category": "Modularity",
      "tags": [],
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RazorPagesConfigurationTests.cs",
        "line": 81,
        "member": "Bravellian.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_invokes_module_configuration"
      },
      "status": "missing-required",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_registers_application_parts",
      "category": "Modularity",
      "tags": [],
      "summary": "When ConfigureRazorModulePages is invoked for a registered Razor module, then its assembly is added to the Razor application parts.",
      "intent": "Verify that Razor module assemblies are registered with Razor pages.",
      "scenario": "Given a module registry containing TestRazorModule and services configured with the required configuration key.",
      "behavior": "Then the MVC ApplicationPartManager includes an AssemblyPart for the module assembly.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RazorPagesConfigurationTests.cs",
        "line": 43,
        "member": "Bravellian.Platform.Tests.Modularity.RazorPagesConfigurationTests.ConfigureRazorModulePages_registers_application_parts"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Discovery_service_resolve_engine_throws_when_factory_returns_null",
      "category": "Modularity",
      "tags": [],
      "summary": "When an engine descriptor factory returns null, then ResolveEngine throws and identifies the module/engine key.",
      "intent": "Guard against null engine factories during discovery resolution.",
      "scenario": "Given a ModuleEngineDescriptor whose factory returns null and an empty service provider.",
      "behavior": "Then ResolveEngine throws an InvalidOperationException mentioning \u0022returned null\u0022 and the descriptor key.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 144,
        "member": "Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Discovery_service_resolve_engine_throws_when_factory_returns_null"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_executes_when_required_services_are_satisfied",
      "category": "Modularity",
      "tags": [],
      "summary": "When required services are satisfied, then ExecuteAsync returns the engine result.",
      "intent": "Confirm successful execution when required services are available.",
      "scenario": "Given RequiredServiceModule is registered and a TestRequiredServiceValidator lists cache and telemetry as available.",
      "behavior": "Then the returned view model contains the expected \u0022ok\u0022 value.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 110,
        "member": "Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_executes_when_required_services_are_satisfied"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_requires_required_service_validator_when_engine_declares_required_services",
      "category": "Modularity",
      "tags": [],
      "summary": "When a UI engine declares required services and no validator is registered, then ExecuteAsync fails and mentions IRequiredServiceValidator.",
      "intent": "Ensure required service validation is enforced when engines declare dependencies.",
      "scenario": "Given RequiredServiceModule is registered and the service collection omits an IRequiredServiceValidator.",
      "behavior": "Then ExecuteAsync throws an InvalidOperationException whose message references IRequiredServiceValidator.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 40,
        "member": "Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_requires_required_service_validator_when_engine_declares_required_services"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    },
    {
      "testId": "Bravellian.Platform.Tests:Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_throws_when_required_services_are_missing",
      "category": "Modularity",
      "tags": [],
      "summary": "When required services are missing, then ExecuteAsync throws with missing service details.",
      "intent": "Validate that required service checks surface missing dependencies in the error message.",
      "scenario": "Given RequiredServiceModule is registered and a TestRequiredServiceValidator reports no available services.",
      "behavior": "Then ExecuteAsync throws and the message contains the missing service name and summary text.",
      "source": {
        "file": "tests/Bravellian.Platform.Tests/Modularity/RequiredServiceValidationTests.cs",
        "line": 74,
        "member": "Bravellian.Platform.Tests.Modularity.RequiredServiceValidationTests.Ui_adapter_throws_when_required_services_are_missing"
      },
      "status": "compliant",
      "project": "Bravellian.Platform.Tests"
    }
  ]
}
